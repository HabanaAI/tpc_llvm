# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=tpc -mcpu=doron1 -run-pass=tpc-inc --tpc-inc-merger=1 %s -o - | FileCheck %s

# Doron1, folding LD_G to IRF and increment.

# Initially obtained from the source:
#
# void main(int dest) {
#   int5 __local *dptr = (int5 __local *)dest;
#   int5 index = {0};
#   int __global *ptr = (int __global *)gen_addr(index, 0, SW_INT32 | SW_DT_OVERRIDE);
#
#   int5 value = i_i32_ld_g(ptr, 0b01011, 0, (int5){0}, 1, 0);
#   *dptr++ = value;
#   index[0] += 1;
#   ptr = (__global__ int*)gen_addr(index, 0);
#   *dptr = *ptr;
# }

--- |
  define void @main(i32 %dest) #0 {
  entry:
    %0 = inttoptr i32 %dest to <5 x i32> addrspace(1)*
    %1 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> zeroinitializer, i8 0, i32 18, i8 addrspace(3)* undef, i1 true, i1 false)
    %2 = call <5 x i32> @llvm.tpc.ld.g.int5(i8 addrspace(3)* %1, i32 11, i32 0, <5 x i32> zeroinitializer, i1 true, i1 false)
    %incdec.ptr = getelementptr inbounds <5 x i32>, <5 x i32> addrspace(1)* %0, i32 1
    store <5 x i32> %2, <5 x i32> addrspace(1)* %0, align 4
    %3 = call <5 x i32> @llvm.tpc.add.mask.v5i32.i32(<5 x i32> zeroinitializer, i32 1, i32 1, i8 2, i32 0, <5 x i32> zeroinitializer, i1 true, i1 false)
    %4 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %3, i8 0, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
    %5 = bitcast i8 addrspace(3)* %4 to i32 addrspace(3)*
    %6 = load i32, i32 addrspace(3)* %5, align 4
    %splat.splatinsert = insertelement <5 x i32> poison, i32 %6, i32 0
    %splat.splat = shufflevector <5 x i32> %splat.splatinsert, <5 x i32> poison, <5 x i32> zeroinitializer
    store <5 x i32> %splat.splat, <5 x i32> addrspace(1)* %incdec.ptr, align 4
    ret void
  }

  declare i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32>, i8, i32, i8 addrspace(3)*, i1, i1) #1
  declare <5 x i32> @llvm.tpc.ld.g.int5(i8 addrspace(3)*, i32, i32, <5 x i32>, i1, i1) #2
  declare <5 x i32> @llvm.tpc.add.mask.v5i32.i32(<5 x i32>, i32, i32, i8, i32, <5 x i32>, i1, i1) #1

  attributes #0 = { nounwind "target-cpu"="doron1" "tpc-kernel"="true" }
  attributes #1 = { nounwind readnone "target-cpu"="doron1" }
  attributes #2 = { nounwind readonly "target-cpu"="doron1" }

...
---
name:            main
tracksRegLiveness: true
body:             |
  bb.0.entry:
    liveins: $i0

    ; CHECK-LABEL: name: main
    ; CHECK: liveins: $i0
    ; CHECK: [[COPY:%[0-9]+]]:irf = COPY $i0
    ; CHECK: [[DEF:%[0-9]+]]:adrf = IMPLICIT_DEF
    ; CHECK: [[GEN_ADDR_st:%[0-9]+]]:adrf = GEN_ADDR_st 0, [[COPY]], 18, [[DEF]], $sprf_true, 0
    ; CHECK: [[DEF1:%[0-9]+]]:irf = IMPLICIT_DEF
    ; CHECK: [[LD_GIap:%[0-9]+]]:irf = LD_GIap killed [[GEN_ADDR_st]](tied-def 7), 11, 3, [[DEF1]](tied-def 0), $sprf_true, 0, implicit-def %11
    ; CHECK: [[DEF2:%[0-9]+]]:irf = IMPLICIT_DEF
    ; CHECK: [[DEF3:%[0-9]+]]:adrf = IMPLICIT_DEF
    ; CHECK: [[DEF4:%[0-9]+]]:srf = IMPLICIT_DEF
    ; CHECK: [[LD_Gsap:%[0-9]+]]:srf = LD_Gsap killed %11, 0, [[DEF4]], $sprf_true, 0 :: (load 4 from %ir.5, addrspace 3)
    ; CHECK: HALTs
    %1:irf = COPY $i0
    %5:adrf = IMPLICIT_DEF
    %4:adrf = GEN_ADDR_st 0, %1, 18, %5, $sprf_true, 0
    %2:irf = IMPLICIT_DEF
    %6:irf = LD_GIap killed %4, 11, 0, %2, $sprf_true, 0
    %7:irf = IMPLICIT_DEF
    %27:irf = ADDiIp 1, %1, 1, 2, 0, %7, $sprf_true, 0
    %29:adrf = IMPLICIT_DEF
    %28:adrf = GEN_ADDR_st 0, killed %27, 0, %29, $sprf_true, 0
    %31:srf = IMPLICIT_DEF
    %30:srf = LD_Gsap killed %28, 0, %31, $sprf_true, 0 :: (load 4 from %ir.5, addrspace 3)
    HALTs

...
