# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=tpc -mcpu=doron1 -run-pass=tpc-inc -tpc-inc-merger=1 %s -o - | FileCheck %s

# Initially obtained from the source:
#
# void main(tensor input, int niter, int niter2, int dest) {
#   int5 index = {0};
#   int64 __local *dest_ptr = (int64 __local *)dest;
#   int64 sum = 0;
#
#   for (int i = 0; i < niter; ++i) {
#     for (int j = 0; j < niter2; ++j) {
#       int64 res = v_i32_ld_tnsr_b(index, input, 0, 0, 1, 0);
#       sum = sum + res;
#       index[1] += 256;
#     }
#     index[0] += 1;
#   }
#   *dest_ptr = sum;
# }


--- |

  define void @main(i32 %niter, i32 %niter2, i32 %dest) #0 {
  entry:
    %cmp30 = icmp sgt i32 %niter, 0
    br i1 %cmp30, label %for.cond1.preheader.lr.ph, label %for.cond.cleanup

  for.cond1.preheader.lr.ph:                        ; preds = %entry
    %cmp225 = icmp sgt i32 %niter2, 0
    br label %for.cond1.preheader

  for.cond1.preheader:                              ; preds = %for.cond.cleanup3, %for.cond1.preheader.lr.ph
    %index.033 = phi <5 x i32> [ zeroinitializer, %for.cond1.preheader.lr.ph ], [ %1, %for.cond.cleanup3 ]
    %i.032 = phi i32 [ 0, %for.cond1.preheader.lr.ph ], [ %inc10, %for.cond.cleanup3 ]
    %sum.031 = phi <64 x i32> [ zeroinitializer, %for.cond1.preheader.lr.ph ], [ %sum.1.lcssa, %for.cond.cleanup3 ]
    br i1 %cmp225, label %for.body4.preheader, label %for.cond.cleanup3

  for.body4.preheader:                              ; preds = %for.cond1.preheader
    br label %for.body4

  for.cond.cleanup:                                 ; preds = %for.cond.cleanup3, %entry
    %sum.0.lcssa = phi <64 x i32> [ zeroinitializer, %entry ], [ %sum.1.lcssa, %for.cond.cleanup3 ]
    %0 = inttoptr i32 %dest to <64 x i32> addrspace(2)*
    store <64 x i32> %sum.0.lcssa, <64 x i32> addrspace(2)* %0, align 256
    ret void

  for.cond.cleanup3:                                ; preds = %for.body4, %for.cond1.preheader
    %sum.1.lcssa = phi <64 x i32> [ %sum.031, %for.cond1.preheader ], [ %add, %for.body4 ]
    %index.1.lcssa = phi <5 x i32> [ %index.033, %for.cond1.preheader ], [ %3, %for.body4 ]
    %1 = tail call <5 x i32> @llvm.tpc.add.mask.v5i32.i32(<5 x i32> %index.1.lcssa, i32 1, i32 1, i8 2, i32 0, <5 x i32> %index.1.lcssa, i1 true, i1 false)
    %inc10 = add nuw nsw i32 %i.032, 1
    %exitcond35.not = icmp eq i32 %inc10, %niter
    br i1 %exitcond35.not, label %for.cond.cleanup, label %for.cond1.preheader

  for.body4:                                        ; preds = %for.body4, %for.body4.preheader
    %lsr.iv = phi i32 [ %lsr.iv.next, %for.body4 ], [ %niter2, %for.body4.preheader ]
    %index.128 = phi <5 x i32> [ %3, %for.body4 ], [ %index.033, %for.body4.preheader ]
    %sum.126 = phi <64 x i32> [ %add, %for.body4 ], [ %sum.031, %for.body4.preheader ]
    %2 = tail call <64 x i32> @llvm.tpc.ld.tnsr.v64i32.i1(<5 x i32> %index.128, i8 0, i32 0, <64 x i32> undef, i1 true, i1 false)
    %add = add <64 x i32> %2, %sum.126
    %3 = tail call <5 x i32> @llvm.tpc.add.mask.v5i32.i32(<5 x i32> %index.128, i32 256, i32 2, i8 2, i32 0, <5 x i32> %index.128, i1 true, i1 false)
    %lsr.iv.next = add i32 %lsr.iv, -1
    %exitcond.not = icmp eq i32 %lsr.iv.next, 0
    br i1 %exitcond.not, label %for.cond.cleanup3, label %for.body4
  }

  ; Function Attrs: nounwind readnone
  declare <64 x i32> @llvm.tpc.ld.tnsr.v64i32.i1(<5 x i32>, i8, i32, <64 x i32>, i1, i1) #1

  ; Function Attrs: nounwind readnone
  declare <5 x i32> @llvm.tpc.add.mask.v5i32.i32(<5 x i32>, i32, i32, i8, i32, <5 x i32>, i1, i1) #1

  attributes #0 = { nofree nounwind writeonly "disable-tail-calls"="false" "frame-pointer"="all" "less-precise-fpmad"="false" "min-legal-vector-width"="0" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="true" "stack-protector-buffer-size"="8" "target-cpu"="doron1" "target-features"="+doron1" "tpc-kernel"="true" "uniform-work-group-size"="true" "unsafe-fp-math"="false" "use-soft-float"="false" }
  attributes #1 = { nounwind readnone "target-cpu"="doron1" }

...
---
name:            main
tracksRegLiveness: true
body:             |
  ; CHECK-LABEL: name: main
  ; CHECK: bb.0.entry:
  ; CHECK:   JMPR_u %bb.1
  
  ; CHECK: bb.1.for.cond1.preheader.lr.ph:
  ; CHECK:   [[DEF4:%[0-9]+]]:irf = IMPLICIT_DEF
  ; CHECK:   [[SET_INDX_ld_ip:%[0-9]+]]:irf = SET_INDX_ld_ip [[DEF4]], 0, 31, 0, $sprf_true, 0
  ; CHECK:   [[DEF6:%[0-9]+]]:vrf = IMPLICIT_DEF
  ; CHECK:   $inc_ld_dim_reg = MOV_ld_hsip 256, 0, $spu_lfsr, $sprf_true, 0
  
  ; CHECK: bb.2.for.cond1.preheader:
  ; CHECK:   [[PHI:%[0-9]+]]:irf = PHI [[SET_INDX_ld_ip]], %bb.1, %22, %bb.4
  ; CHECK:   JMPR_u %bb.5

  ; CHECK: bb.5.for.body4:
  ; CHECK:   [[PHI7:%[0-9]+]]:irf = PHI [[PHI]], %bb.2, %40, %bb.5
  ; CHECK:   [[LD_TNSRvp:%[0-9]+]]:vrf = LD_TNSRvp [[PHI7]](tied-def 7), 0, 256, [[DEF6]](tied-def 0), $sprf_true, 0, implicit-def %40, implicit $inc_ld_dim_reg
  bb.0.entry:
    successors: %bb.1(0x50000000), %bb.4(0x30000000)
    liveins: $s0, $s1, $s2

    %17:srf = COPY $s2
    %16:srf = COPY $s1
    %15:srf = COPY $s0
    %20:sprf = IMPLICIT_DEF
    %19:sprf = CMP_LESSsip %15, 1, 2, 0, %20, $sprf_true, 0
    %21:vrf = IMPLICIT_DEF
    %18:vrf = MOV_ld_vip 0, 2, 0, %21, $sprf_true, 0
    JMPR %bb.4, killed %19, 0
    JMPR_u %bb.1

  bb.1.for.cond1.preheader.lr.ph:
    successors: %bb.2(0x80000000)

    %25:sprf = IMPLICIT_DEF
    %0:sprf = CMP_GRTsip %16, 0, 2, 0, %25, $sprf_true, 0
    %26:vrf = IMPLICIT_DEF
    %24:vrf = MOV_ld_vip 0, 2, 0, %26, $sprf_true, 0
    %27:irf = IMPLICIT_DEF
    %22:irf = SET_INDX_ld_ip %27, 0, 31, 0, $sprf_true, 0
    %28:srf = IMPLICIT_DEF
    %23:srf = MOVsip 0, 2, 0, %28, $sprf_true, 0
    %31:vrf = IMPLICIT_DEF
    %32:vrf = IMPLICIT_DEF
    %33:srf = IMPLICIT_DEF
    %35:sprf = IMPLICIT_DEF
    %37:srf = IMPLICIT_DEF
    %39:sprf = IMPLICIT_DEF

  bb.2.for.cond1.preheader:
    successors: %bb.6(0x50000000), %bb.5(0x30000000)

    %1:irf = PHI %22, %bb.1, %7, %bb.5
    %2:srf = PHI %23, %bb.1, %8, %bb.5
    %3:vrf = PHI %24, %bb.1, %5, %bb.5
    JMPR %bb.5, %0, -1
    JMPR_u %bb.6

  bb.4.for.cond.cleanup:
    %4:vrf = PHI %18, %bb.0, %5, %bb.5
    ST_L_Vsvp %17, %4, 0, $sprf_true, 0 :: (store 256 into %ir.0, addrspace 2)
    HALTs

  bb.5.for.cond.cleanup3:
    successors: %bb.4(0x04000000), %bb.2(0x7c000000)

    %5:vrf = PHI %3, %bb.2, %12, %bb.6
    %6:irf = PHI %1, %bb.2, %13, %bb.6
    %36:sprf = COPY $sprf_true
    %7:irf = ADDiIp 1, %6, 1, 2, 0, %6, $sprf_true, 0
    %8:srf = nuw nsw ADDsip %2, 1, 2, 0, %37, $sprf_true, 0
    %38:sprf = CMP_EQssp %8, %15, 2, 0, %39, $sprf_true, 0
    JMPR %bb.4, killed %38, 0
    JMPR_u %bb.2

  bb.6.for.body4:
    successors: %bb.5(0x04000000), %bb.6(0x7c000000)

    %9:srf = PHI %16, %bb.2, %14, %bb.6
    %10:irf = PHI %1, %bb.2, %13, %bb.6
    %11:vrf = PHI %3, %bb.2, %12, %bb.6
    %29:sprf = COPY $sprf_true
    %30:vrf = LD_TNSRvp %10, 0, 1792, %31, $sprf_true, 0
    %12:vrf = ADDvvp killed %30, %11, 2, 0, %32, $sprf_true, 0
    %13:irf = ADDiIp 256, %10, 2, 2, 0, %10, $sprf_true, 0
    %14:srf = ADDsip %9, -1, 2, 0, %33, $sprf_true, 0
    %34:sprf = CMP_EQsip %14, 0, 2, 0, %35, $sprf_true, 0
    JMPR %bb.5, killed %34, 0
    JMPR_u %bb.6

...

