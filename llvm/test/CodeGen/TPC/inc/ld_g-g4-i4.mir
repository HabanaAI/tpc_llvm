# NOTE: Assertions have been autogenerated by utils/update_mir_test_checks.py
# RUN: llc -mtriple=tpc -mcpu=gaudi2 -run-pass=tpc-inc -tpc-inc-merger=1 %s -o - | FileCheck %s

# Gaudi2, increment by 4.

# Initially obtained from the source:
#
# void main(int dest) {
#   int __local *dptr = (int __local *)dest;
#   int5 index = {0};
#   int __global *ptr = (int __global *)gen_addr(index, 0, SW_INT32 | SW_DT_OVERRIDE);
#   *dptr++ = *ptr;
#   index[0] += 1;
#   ptr = (__global__ int*)gen_addr(index, 0);
#   *dptr = *ptr;
# }

--- |
  define void @main(i32 %dest) #0 {
  entry:
    %dptr.0 = inttoptr i32 %dest to i32 addrspace(1)*
    %adrf.0 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> zeroinitializer, i8 0, i32 18, i8 addrspace(3)* undef, i1 true, i1 false)
    %addr.0 = bitcast i8 addrspace(3)* %adrf.0 to i32 addrspace(3)*
    %val.0 = load i32, i32 addrspace(3)* %addr.0, align 4
    store i32 %val.0, i32 addrspace(1)* %dptr.0, align 4
    %dptr.1 = getelementptr inbounds i32, i32 addrspace(1)* %dptr.0, i32 1
    %index.1 = call <5 x i32> @llvm.tpc.add.mask.v5i32.i32(<5 x i32> zeroinitializer, i32 1, i32 1, i8 2, i32 0, <5 x i32> zeroinitializer, i1 true, i1 false)
    %adrf.1 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %index.1, i8 0, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
    %addr.1 = bitcast i8 addrspace(3)* %adrf.1 to i32 addrspace(3)*
    %val.1 = load i32, i32 addrspace(3)* %addr.1, align 4
    store i32 %val.1, i32 addrspace(1)* %dptr.1, align 4
    ret void
  }

  declare i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32>, i8, i32, i8 addrspace(3)*, i1, i1) #1
  declare <5 x i32> @llvm.tpc.add.mask.v5i32.i32(<5 x i32>, i32, i32, i8, i32, <5 x i32>, i1, i1) #1

  attributes #0 = { nounwind willreturn "target-cpu"="gaudi2" "tpc-kernel"="true" }
  attributes #1 = { nounwind readnone "target-cpu"="gaudi2" }

...
---
name:            main
tracksRegLiveness: true
body:             |
  bb.0.entry:
    liveins: $s0
    ; CHECK-LABEL: name: main
    ; CHECK: liveins: $s0
    ; CHECK: [[DEF:%[0-9]+]]:irf = IMPLICIT_DEF
    ; CHECK: [[SET_INDX_ld_ip:%[0-9]+]]:irf = SET_INDX_ld_ip [[DEF]], 0, 31, 0, $sprf_true, 0
    ; CHECK: [[DEF1:%[0-9]+]]:adrf = IMPLICIT_DEF
    ; CHECK: [[GEN_ADDR_st:%[0-9]+]]:adrf = GEN_ADDR_st 0, [[SET_INDX_ld_ip]], 18, [[DEF1]], $sprf_true, 0
    ; CHECK: [[DEF2:%[0-9]+]]:srf = IMPLICIT_DEF
    ; CHECK: [[LD_Gsap:%[0-9]+]]:srf = LD_Gsap killed [[GEN_ADDR_st]](tied-def 6), 3, [[DEF2]](tied-def 0), $sprf_true, 0, implicit-def %11 :: (load 4 from %ir.addr.0, addrspace 3)
    ; CHECK: [[DEF3:%[0-9]+]]:adrf = IMPLICIT_DEF
    ; CHECK: [[DEF4:%[0-9]+]]:srf = IMPLICIT_DEF
    ; CHECK: [[LD_Gsap1:%[0-9]+]]:srf = LD_Gsap killed %11, 0, [[DEF4]], $sprf_true, 0 :: (load 4 from %ir.addr.1, addrspace 3)
    ; CHECK: HALTs
    %2:irf = IMPLICIT_DEF
    %1:irf = SET_INDX_ld_ip %2, 0, 31, 0, $sprf_true, 0
    %5:adrf = IMPLICIT_DEF
    %4:adrf = GEN_ADDR_st 0, %1, 18, %5, $sprf_true, 0
    %7:srf = IMPLICIT_DEF
    %6:srf = LD_Gsap killed %4, 0, %7, $sprf_true, 0 :: (load 4 from %ir.addr.0, addrspace 3)
    %10:irf = ADDiIp 1, %1, 1, 2, 0, %1, $sprf_true, 0
    %12:adrf = IMPLICIT_DEF
    %11:adrf = GEN_ADDR_st 0, killed %10, 0, %12, $sprf_true, 0
    %14:srf = IMPLICIT_DEF
    %13:srf = LD_Gsap killed %11, 0, %14, $sprf_true, 0 :: (load 4 from %ir.addr.1, addrspace 3)
    HALTs

...
