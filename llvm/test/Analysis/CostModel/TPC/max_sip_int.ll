; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s -cost-model -cost-kind=latency -analyze -mtriple=tpc -mcpu=dali | FileCheck %s --check-prefix=LATENCY
;XFAIL:*

target datalayout = "e-p0:32:32:32-p1:32:32:32-p2:32:32:32-p3:64:64:64-i32:32:32-i16:32:32-i8:32:32-n8:16:32-f16:16:16-f32:32:32-v16:32:32-v32:32:32-v160:32:32-v256:2048:2048-v2048:2048:2048-v4096:2048:2048-v8192:2048:2048"
target triple = "tpc"

@slmShort = external dso_local addrspace(1) global [20 x i32], section ".sldata", align 4
@slmByte = external dso_local addrspace(1) global [20 x i32], section ".sldata", align 4
@slm = external dso_local addrspace(1) global [20 x i32], section ".sldata", align 4

; Function Attrs: nounwind
define dso_local void @main() local_unnamed_addr #0 {
; LATENCY-LABEL: 'main'
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %0 = tail call <5 x i32> @llvm.tpc.get.index.space.offset()
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %1 = tail call <5 x i32> @llvm.tpc.get.index.space.size()
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add = add <5 x i32> %1, %0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext = extractelement <5 x i32> %0, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext1 = extractelement <5 x i32> %add, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %mul231 = sub i32 %vecext1, %vecext
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub = shl i32 %mul231, 6
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %cmp32 = icmp sgt i32 %sub, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %cmp32, label %for.body.preheader, label %for.cond.cleanup
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %2 = shl i32 %vecext, 6
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %3 = shl i32 %vecext1, 6
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %4 = xor i32 %3, -1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = add i32 %2, %4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %6 = icmp sgt i32 %5, -129
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %smax = select i1 %6, i32 %5, i32 -129
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %7 = add i32 %smax, %3
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %8 = add i32 %7, 128
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = sub i32 %8, %2
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %10 = lshr i32 %9, 7
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.body
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.cond.cleanup
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %remLength.036 = phi i32 [ %sub8, %for.body ], [ %sub, %for.body.preheader ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %counterChar.035 = phi i8 [ %inc7, %for.body ], [ 0, %for.body.preheader ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %counterShort.034 = phi i16 [ %inc6, %for.body ], [ 64, %for.body.preheader ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %slmIdx.033 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %11 = icmp sgt i32 %remLength.036, 128
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %12 = select i1 %11, i32 %remLength.036, i32 128
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %13 = icmp sgt i16 %counterShort.034, 128
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = select i1 %13, i16 %counterShort.034, i16 128
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %15 = icmp sgt i8 %counterChar.035, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %16 = select i1 %15, i8 %counterChar.035, i8 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %17 = zext i16 %14 to i32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx = getelementptr inbounds [20 x i32], [20 x i32] addrspace(1)* null, i32 0, i32 %slmIdx.033
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %17, i32 addrspace(1)* %arrayidx, align 4, !tbaa !2
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = zext i8 %16 to i32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx4 = getelementptr inbounds [20 x i32], [20 x i32] addrspace(1)* inttoptr (i32 80 to [20 x i32] addrspace(1)*), i32 0, i32 %slmIdx.033
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %18, i32 addrspace(1)* %arrayidx4, align 4, !tbaa !2
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx5 = getelementptr inbounds [20 x i32], [20 x i32] addrspace(1)* inttoptr (i32 160 to [20 x i32] addrspace(1)*), i32 0, i32 %slmIdx.033
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %12, i32 addrspace(1)* %arrayidx5, align 4, !tbaa !2
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc = add nuw nsw i32 %slmIdx.033, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc6 = add i16 %counterShort.034, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc7 = add i8 %counterChar.035, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub8 = add nsw i32 %remLength.036, -128
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %exitcond = icmp eq i32 %slmIdx.033, %10
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body
;
entry:
  %0 = tail call <5 x i32> @llvm.tpc.get.index.space.offset()
  %1 = tail call <5 x i32> @llvm.tpc.get.index.space.size()
  %add = add <5 x i32> %1, %0
  %vecext = extractelement <5 x i32> %0, i32 0
  %vecext1 = extractelement <5 x i32> %add, i32 0
  %mul231 = sub i32 %vecext1, %vecext
  %sub = shl i32 %mul231, 6
  %cmp32 = icmp sgt i32 %sub, 0
  br i1 %cmp32, label %for.body.preheader, label %for.cond.cleanup

for.body.preheader:                               ; preds = %entry
  %2 = shl i32 %vecext, 6
  %3 = shl i32 %vecext1, 6
  %4 = xor i32 %3, -1
  %5 = add i32 %2, %4
  %6 = icmp sgt i32 %5, -129
  %smax = select i1 %6, i32 %5, i32 -129
  %7 = add i32 %smax, %3
  %8 = add i32 %7, 128
  %9 = sub i32 %8, %2
  %10 = lshr i32 %9, 7
  br label %for.body

for.cond.cleanup.loopexit:                        ; preds = %for.body
  br label %for.cond.cleanup

for.cond.cleanup:                                 ; preds = %for.cond.cleanup.loopexit, %entry
  ret void

for.body:                                         ; preds = %for.body, %for.body.preheader
  %remLength.036 = phi i32 [ %sub8, %for.body ], [ %sub, %for.body.preheader ]
  %counterChar.035 = phi i8 [ %inc7, %for.body ], [ 0, %for.body.preheader ]
  %counterShort.034 = phi i16 [ %inc6, %for.body ], [ 64, %for.body.preheader ]
  %slmIdx.033 = phi i32 [ %inc, %for.body ], [ 0, %for.body.preheader ]
  %11 = icmp sgt i32 %remLength.036, 128
  %12 = select i1 %11, i32 %remLength.036, i32 128
  %13 = icmp sgt i16 %counterShort.034, 128
  %14 = select i1 %13, i16 %counterShort.034, i16 128
  %15 = icmp sgt i8 %counterChar.035, 64
  %16 = select i1 %15, i8 %counterChar.035, i8 64
  %17 = zext i16 %14 to i32
  %arrayidx = getelementptr inbounds [20 x i32], [20 x i32] addrspace(1)* null, i32 0, i32 %slmIdx.033
  store volatile i32 %17, i32 addrspace(1)* %arrayidx, align 4, !tbaa !4
  %18 = zext i8 %16 to i32
  %arrayidx4 = getelementptr inbounds [20 x i32], [20 x i32] addrspace(1)* inttoptr (i32 80 to [20 x i32] addrspace(1)*), i32 0, i32 %slmIdx.033
  store volatile i32 %18, i32 addrspace(1)* %arrayidx4, align 4, !tbaa !4
  %arrayidx5 = getelementptr inbounds [20 x i32], [20 x i32] addrspace(1)* inttoptr (i32 160 to [20 x i32] addrspace(1)*), i32 0, i32 %slmIdx.033
  store volatile i32 %12, i32 addrspace(1)* %arrayidx5, align 4, !tbaa !4
  %inc = add nuw nsw i32 %slmIdx.033, 1
  %inc6 = add i16 %counterShort.034, 1
  %inc7 = add i8 %counterChar.035, 1
  %sub8 = add nsw i32 %remLength.036, -128
  %exitcond = icmp eq i32 %slmIdx.033, %10
  br i1 %exitcond, label %for.cond.cleanup.loopexit, label %for.body
}

; Function Attrs: nounwind readnone
declare <5 x i32> @llvm.tpc.get.index.space.offset() #1

; Function Attrs: nounwind readnone
declare <5 x i32> @llvm.tpc.get.index.space.size() #1

attributes #0 = { nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="dali" "target-features"="+dali" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone }

!llvm.tpc.scalar_data = !{!2}
!llvm.tpc.vector_data = !{!3}

!2 = !{i32 240}
!3 = !{i32 256}
!4 = !{!5, !5, i64 0}
!5 = !{!"int", !6, i64 0}
!6 = !{!"omnipotent char", !7, i64 0}
!7 = !{!"Simple C/C++ TBAA"}

; CHECK: max  %S{{[0-9]+}}, %S{{[0-9]+}}, 0x80, %SP{{[0-9]+}}
; CHECK: max  %S{{[0-9]+}}, %S{{[0-9]+}}, 0x40, %SP{{[0-9]+}}
; CHECK: max.i32  %S{{[0-9]+}}, %S{{[0-9]+}}, 0x80, %SP{{[0-9]+}}
; CHECK: and.i32  %S{{[0-9]+}}, %S{{[0-9]+}}, 0xffff, %SP{{[0-9]+}}
; CHECK: and.i32  %S{{[0-9]+}}, %S{{[0-9]+}}, 0xff, %SP{{[0-9]+}}
