; NOTE: Assertions have been autogenerated by utils/update_analyze_test_checks.py
; RUN: opt < %s -cost-model -cost-kind=latency -analyze -mtriple=tpc -mcpu=goya2 | FileCheck %s --check-prefix=LATENCY
; XFAIL: *
target datalayout = "e-p0:32:32:32-p1:32:32:32-p2:32:32:32-p3:64:64:64-i32:32:32-n8:16:32-f16:16:16-f32:32:32-v160:32:32-v256:2048:2048-v2048:2048:2048-v4096:2048:2048-v8192:2048:2048"
target triple = "tpc"

@slm = external dso_local addrspace(1) global [256 x i32], section ".sldata", align 4
@index_space_start = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@index_space_end = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@depth_start = external dso_local addrspace(1) global i32, section ".sldata"
@depth_end = external dso_local addrspace(1) global i32, section ".sldata"
@validCount = external dso_local addrspace(1) global i32, section ".sldata"
@width_start = external dso_local addrspace(1) global i32, section ".sldata"
@width_end = external dso_local addrspace(1) global i32, section ".sldata"
@inputCoord0 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@inputCoord1 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@inputCoord2 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@inputCoord3 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@outputCoord0 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@outputCoord1 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@outputCoord2 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@outputCoord3 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@indicesCoord0 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@indicesCoord1 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@indicesCoord2 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@indicesCoord3 = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@inputVec0 = external dso_local addrspace(2) global <64 x float>, section ".vldata"
@inputVec1 = external dso_local addrspace(2) global <64 x float>, section ".vldata"
@inputVec2 = external dso_local addrspace(2) global <64 x float>, section ".vldata"
@inputVec3 = external dso_local addrspace(2) global <64 x float>, section ".vldata"
@indexOffset = external dso_local addrspace(1) global i32, section ".sldata"
@slmIdx = external dso_local addrspace(1) global i32, section ".sldata"
@lenStart = external dso_local addrspace(1) global i32, section ".sldata"
@lenEnd = external dso_local addrspace(1) global i32, section ".sldata"
@lenToprocess = external dso_local addrspace(1) global i32, section ".sldata"
@remLength = external dso_local addrspace(1) global i32, section ".sldata"
@w = external dso_local addrspace(1) global i32, section ".sldata"
@lengthsCoord = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@prefetchCoord = external dso_local addrspace(1) global <5 x i32>, section ".sldata"
@e = external dso_local addrspace(1) global i32, section ".sldata"
@offset0 = external dso_local addrspace(1) global i32, section ".sldata"
@cachedOffsetsEnd = external dso_local addrspace(1) global i32, section ".sldata"
@segNo = external dso_local addrspace(1) global i32, section ".sldata"
@offset1 = external dso_local addrspace(1) global i32, section ".sldata"
@offset2 = external dso_local addrspace(1) global i32, section ".sldata"
@offset3 = external dso_local addrspace(1) global i32, section ".sldata"
@offset4 = external dso_local addrspace(1) global i32, section ".sldata"
@offset5 = external dso_local addrspace(1) global i32, section ".sldata"
@offset6 = external dso_local addrspace(1) global i32, section ".sldata"
@offset7 = external dso_local addrspace(1) global i32, section ".sldata"
@offset8 = external dso_local addrspace(1) global i32, section ".sldata"
@length0 = external dso_local addrspace(1) global i32, section ".sldata"
@length1 = external dso_local addrspace(1) global i32, section ".sldata"
@length2 = external dso_local addrspace(1) global i32, section ".sldata"
@length3 = external dso_local addrspace(1) global i32, section ".sldata"
@length4 = external dso_local addrspace(1) global i32, section ".sldata"
@length5 = external dso_local addrspace(1) global i32, section ".sldata"
@length6 = external dso_local addrspace(1) global i32, section ".sldata"
@length7 = external dso_local addrspace(1) global i32, section ".sldata"
@segmentStart = external dso_local addrspace(1) global i32, section ".sldata"
@depth = external dso_local addrspace(1) global i32, section ".sldata"
@prefetched_lenght = external dso_local addrspace(1) global i32, section ".sldata"
@completed_length = external dso_local addrspace(1) global i32, section ".sldata"
@slm_index0 = external dso_local addrspace(1) global i32, section ".sldata"
@slm_index1 = external dso_local addrspace(1) global i32, section ".sldata"
@slm_index2 = external dso_local addrspace(1) global i32, section ".sldata"
@slm_index3 = external dso_local addrspace(1) global i32, section ".sldata"
@segNoEnd = external dso_local addrspace(1) global i32, section ".sldata"
@segNo154 = external dso_local addrspace(1) global i32, section ".sldata"
@segment_length0 = external dso_local addrspace(1) global i32, section ".sldata"
@segment_length1 = external dso_local addrspace(1) global i32, section ".sldata"
@segment_length2 = external dso_local addrspace(1) global i32, section ".sldata"
@segment_length3 = external dso_local addrspace(1) global i32, section ".sldata"
@segment_length = external dso_local addrspace(1) global i32, section ".sldata"
@segment_length01 = external dso_local addrspace(1) global i32, section ".sldata"
@segment_length23 = external dso_local addrspace(1) global i32, section ".sldata"
@iterations_length = external dso_local addrspace(1) global i32, section ".sldata"
@accVec0 = external dso_local addrspace(2) global <64 x float>, section ".vldata"
@accVec1 = external dso_local addrspace(2) global <64 x float>, section ".vldata"
@accVec2 = external dso_local addrspace(2) global <64 x float>, section ".vldata"
@accVec3 = external dso_local addrspace(2) global <64 x float>, section ".vldata"
@remainingIdx = external dso_local addrspace(1) global i32, section ".sldata"
@pred0 = external dso_local addrspace(1) global i8, section ".sldata"
@pred1 = external dso_local addrspace(1) global i8, section ".sldata"
@pred2 = external dso_local addrspace(1) global i8, section ".sldata"
@pred3 = external dso_local addrspace(1) global i8, section ".sldata"
@index0 = external dso_local addrspace(1) global i32, section ".sldata"
@index1 = external dso_local addrspace(1) global i32, section ".sldata"
@index2 = external dso_local addrspace(1) global i32, section ".sldata"
@index3 = external dso_local addrspace(1) global i32, section ".sldata"
@pred_pref = external dso_local addrspace(1) global i8, section ".sldata"

; Function Attrs: noinline nounwind
define dso_local void @main() #0 {
; LATENCY-LABEL: 'main'
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %0 = call <5 x i32> @llvm.tpc.get.index.space.offset()
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %0, <5 x i32> addrspace(1)* inttoptr (i32 1024 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %1 = call <5 x i32> @llvm.tpc.get.index.space.size()
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add = add <5 x i32> %1, %0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %add, <5 x i32> addrspace(1)* inttoptr (i32 1044 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext = extractelement <5 x i32> %0, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %mul = shl nsw i32 %vecext, 6
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %mul, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext1 = extractelement <5 x i32> %add, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %mul2 = shl nsw i32 %vecext1, 6
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %mul2, i32 addrspace(1)* inttoptr (i32 1068 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %2 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> zeroinitializer, i8 3, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %3 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %2, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %3, i32 addrspace(1)* inttoptr (i32 1072 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %shr = ashr i32 %3, 3
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %4 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1024 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext3 = extractelement <5 x i32> %4, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %mul4 = mul nsw i32 %vecext3, %shr
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %5 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1044 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext5 = extractelement <5 x i32> %5, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %mul6 = mul nsw i32 %vecext5, %shr
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %6 = and i32 %mul4, -32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %6, i32 addrspace(1)* inttoptr (i32 1076 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add8 = add nsw i32 %mul6, 31
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %7 = and i32 %add8, -32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %7, i32 addrspace(1)* inttoptr (i32 1080 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %8 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1044 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext11 = extractelement <5 x i32> %8, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %cmp = icmp eq i32 %vecext11, 8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %cmp, label %if.then, label %if.end
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %9 = load i32, i32 addrspace(1)* inttoptr (i32 1072 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %9, i32 addrspace(1)* inttoptr (i32 1080 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %if.end
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 0, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 0, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %10 = load i32, i32 addrspace(1)* inttoptr (i32 1076 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %10, i32 addrspace(1)* inttoptr (i32 1336 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 0, i32 addrspace(1)* inttoptr (i32 1340 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %11 = load i32, i32 addrspace(1)* inttoptr (i32 1080 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub = sub nsw i32 %11, %10
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub, i32 addrspace(1)* inttoptr (i32 1344 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.cond
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %storemerge = phi i32 [ %10, %if.end ], [ %add278, %for.inc277 ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %storemerge, i32 addrspace(1)* inttoptr (i32 1348 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %12 = load i32, i32 addrspace(1)* inttoptr (i32 1080 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %cmp12 = icmp slt i32 %storemerge, %12
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %cmp12, label %for.body, label %for.end279
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %13 = load i32, i32 addrspace(1)* inttoptr (i32 1344 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %14 = call i32 @llvm.tpc.min.i32.i32.i32.i1(i32 %13, i32 256, i8 2, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %14, i32 addrspace(1)* inttoptr (i32 1340 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub13 = add nsw i32 %13, -256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub13, i32 addrspace(1)* inttoptr (i32 1344 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %15 = load i32, i32 addrspace(1)* inttoptr (i32 1336 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %15, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add14 = add nsw i32 %15, %14
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add14, i32 addrspace(1)* inttoptr (i32 1336 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 0, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecinit18 = insertelement <5 x i32> <i32 undef, i32 0, i32 0, i32 0, i32 0>, i32 %15, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecinit18, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecinit23 = insertelement <5 x i32> <i32 undef, i32 0, i32 0, i32 0, i32 0>, i32 %15, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecinit23, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.cond24
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %storemerge280 = phi i32 [ 0, %for.body ], [ %add122, %for.inc121 ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %storemerge280, i32 addrspace(1)* inttoptr (i32 1392 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %16 = load i32, i32 addrspace(1)* inttoptr (i32 1340 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %cmp25 = icmp slt i32 %storemerge280, %16
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %cmp25, label %for.body26, label %for.end123
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %17 = load i32, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %18 = load i32, i32 addrspace(1)* inttoptr (i32 1392 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add27 = add nsw i32 %17, %18
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add28 = add nsw i32 %add27, 32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add28, i32 addrspace(1)* inttoptr (i32 1400 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %19 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %20 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %19, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext29 = extractelement <5 x i32> %19, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add30 = add nsw i32 %vecext29, 32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins = insertelement <5 x i32> %19, i32 %add30, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %21 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add32 = add nsw i32 %vecext29, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins33 = insertelement <5 x i32> %vecins, i32 %add32, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %22 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins33, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add35 = add nsw i32 %vecext29, 96
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins36 = insertelement <5 x i32> %vecins33, i32 %add35, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %23 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins36, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub38 = add nsw i32 %vecext29, 32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins39 = insertelement <5 x i32> %vecins36, i32 %sub38, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins39, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %20, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %21, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %22, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %23, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %24 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %25 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %24, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %26 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %25, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %26, i32 addrspace(1)* inttoptr (i32 1396 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext40 = extractelement <5 x i32> %24, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add41 = add nsw i32 %vecext40, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins42 = insertelement <5 x i32> %24, i32 %add41, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins42, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %27 = load i32, i32 addrspace(1)* inttoptr (i32 1392 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %cmp43 = icmp eq i32 %27, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %cmp43, label %if.then44, label %if.end45
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %28 = load i32, i32 addrspace(1)* inttoptr (i32 1396 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %28, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %if.end45
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %29 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %30 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %29, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext46 = extractelement <5 x i32> %29, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add47 = add nsw i32 %vecext46, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins48 = insertelement <5 x i32> %29, i32 %add47, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %31 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins48, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add50 = add nsw i32 %vecext46, 2
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins51 = insertelement <5 x i32> %vecins48, i32 %add50, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %32 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins51, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add53 = add nsw i32 %vecext46, 3
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins54 = insertelement <5 x i32> %vecins51, i32 %add53, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %33 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins54, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add56 = add nsw i32 %vecext46, 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins57 = insertelement <5 x i32> %vecins54, i32 %add56, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %34 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins57, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add59 = add nsw i32 %vecext46, 5
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins60 = insertelement <5 x i32> %vecins57, i32 %add59, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %35 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins60, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add62 = add nsw i32 %vecext46, 6
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins63 = insertelement <5 x i32> %vecins60, i32 %add62, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %36 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins63, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add65 = add nsw i32 %vecext46, 7
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins66 = insertelement <5 x i32> %vecins63, i32 %add65, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %37 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins66, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add68 = add nsw i32 %vecext46, 8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins69 = insertelement <5 x i32> %vecins66, i32 %add68, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins69, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.cond70
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %storemerge282 = phi i32 [ 0, %if.end45 ], [ %add119, %for.inc ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %prt6.0.in = phi i8 addrspace(3)* [ %36, %if.end45 ], [ %52, %for.inc ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %prt5.0.in = phi i8 addrspace(3)* [ %35, %if.end45 ], [ %50, %for.inc ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %prt4.0.in = phi i8 addrspace(3)* [ %34, %if.end45 ], [ %48, %for.inc ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %prt3.0.in = phi i8 addrspace(3)* [ %33, %if.end45 ], [ %46, %for.inc ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %prt2.0.in = phi i8 addrspace(3)* [ %32, %if.end45 ], [ %44, %for.inc ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %prt1.0.in = phi i8 addrspace(3)* [ %31, %if.end45 ], [ %42, %for.inc ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %prt0.0.in = phi i8 addrspace(3)* [ %30, %if.end45 ], [ %40, %for.inc ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %prt7.0.in = phi i8 addrspace(3)* [ %37, %if.end45 ], [ %54, %for.inc ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %storemerge282, i32 addrspace(1)* inttoptr (i32 1404 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %cmp71 = icmp slt i32 %storemerge282, 32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %cmp71, label %for.body72, label %for.end
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %38 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt0.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %38, i32 addrspace(1)* inttoptr (i32 1408 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %39 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %40 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %39, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext73 = extractelement <5 x i32> %39, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add74 = add nsw i32 %vecext73, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins75 = insertelement <5 x i32> %39, i32 %add74, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins75, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %41 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt1.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %41, i32 addrspace(1)* inttoptr (i32 1412 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %42 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins75, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add77 = add nsw i32 %vecext73, 2
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins78 = insertelement <5 x i32> %vecins75, i32 %add77, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins78, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %43 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt2.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %43, i32 addrspace(1)* inttoptr (i32 1416 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %44 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins78, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add80 = add nsw i32 %vecext73, 3
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins81 = insertelement <5 x i32> %vecins78, i32 %add80, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins81, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %45 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt3.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %45, i32 addrspace(1)* inttoptr (i32 1420 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %46 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins81, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add83 = add nsw i32 %vecext73, 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins84 = insertelement <5 x i32> %vecins81, i32 %add83, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins84, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %47 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt4.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %47, i32 addrspace(1)* inttoptr (i32 1424 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %48 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins84, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add86 = add nsw i32 %vecext73, 5
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins87 = insertelement <5 x i32> %vecins84, i32 %add86, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins87, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %49 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt5.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %49, i32 addrspace(1)* inttoptr (i32 1428 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %50 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins87, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add89 = add nsw i32 %vecext73, 6
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins90 = insertelement <5 x i32> %vecins87, i32 %add89, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins90, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %51 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt6.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %51, i32 addrspace(1)* inttoptr (i32 1432 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %52 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins90, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add92 = add nsw i32 %vecext73, 7
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins93 = insertelement <5 x i32> %vecins90, i32 %add92, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins93, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %53 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt7.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %53, i32 addrspace(1)* inttoptr (i32 1436 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %54 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins93, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add95 = add nsw i32 %vecext73, 8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins96 = insertelement <5 x i32> %vecins93, i32 %add95, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins96, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %55 = load i32, i32 addrspace(1)* inttoptr (i32 1408 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %56 = load i32, i32 addrspace(1)* inttoptr (i32 1396 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub97 = sub nsw i32 %55, %56
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub97, i32 addrspace(1)* inttoptr (i32 1440 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %57 = load i32, i32 addrspace(1)* inttoptr (i32 1412 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub98 = sub nsw i32 %57, %55
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub98, i32 addrspace(1)* inttoptr (i32 1444 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %58 = load i32, i32 addrspace(1)* inttoptr (i32 1416 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub99 = sub nsw i32 %58, %57
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub99, i32 addrspace(1)* inttoptr (i32 1448 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %59 = load i32, i32 addrspace(1)* inttoptr (i32 1420 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub100 = sub nsw i32 %59, %58
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub100, i32 addrspace(1)* inttoptr (i32 1452 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %60 = load i32, i32 addrspace(1)* inttoptr (i32 1424 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub101 = sub nsw i32 %60, %59
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub101, i32 addrspace(1)* inttoptr (i32 1456 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %61 = load i32, i32 addrspace(1)* inttoptr (i32 1428 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub102 = sub nsw i32 %61, %60
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub102, i32 addrspace(1)* inttoptr (i32 1460 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %62 = load i32, i32 addrspace(1)* inttoptr (i32 1432 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub103 = sub nsw i32 %62, %61
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub103, i32 addrspace(1)* inttoptr (i32 1464 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %63 = load i32, i32 addrspace(1)* inttoptr (i32 1436 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub104 = sub nsw i32 %63, %62
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub104, i32 addrspace(1)* inttoptr (i32 1468 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %63, i32 addrspace(1)* inttoptr (i32 1396 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %64 = load i32, i32 addrspace(1)* inttoptr (i32 1440 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %65 = load i32, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc = add nsw i32 %65, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %inc, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %65
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %64, i32 addrspace(1)* %arrayidx, align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %66 = load i32, i32 addrspace(1)* inttoptr (i32 1444 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc105 = add nsw i32 %65, 2
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %inc105, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx106 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %66, i32 addrspace(1)* %arrayidx106, align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %67 = load i32, i32 addrspace(1)* inttoptr (i32 1448 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc107 = add nsw i32 %65, 3
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %inc107, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx108 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc105
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %67, i32 addrspace(1)* %arrayidx108, align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %68 = load i32, i32 addrspace(1)* inttoptr (i32 1452 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc109 = add nsw i32 %65, 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %inc109, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx110 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc107
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %68, i32 addrspace(1)* %arrayidx110, align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %69 = load i32, i32 addrspace(1)* inttoptr (i32 1456 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc111 = add nsw i32 %65, 5
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %inc111, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx112 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc109
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %69, i32 addrspace(1)* %arrayidx112, align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %70 = load i32, i32 addrspace(1)* inttoptr (i32 1460 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc113 = add nsw i32 %65, 6
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %inc113, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx114 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc111
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %70, i32 addrspace(1)* %arrayidx114, align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %71 = load i32, i32 addrspace(1)* inttoptr (i32 1464 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc115 = add nsw i32 %65, 7
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %inc115, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx116 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc113
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %71, i32 addrspace(1)* %arrayidx116, align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %72 = load i32, i32 addrspace(1)* inttoptr (i32 1468 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %inc117 = add nsw i32 %65, 8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %inc117, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %arrayidx118 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc115
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store volatile i32 %72, i32 addrspace(1)* %arrayidx118, align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.inc
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %73 = load i32, i32 addrspace(1)* inttoptr (i32 1404 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add119 = add nsw i32 %73, 8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.cond70, !llvm.loop !4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %74 = load i32, i32 addrspace(1)* inttoptr (i32 1400 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %75 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins120 = insertelement <5 x i32> %75, i32 %74, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins120, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.inc121
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %76 = load i32, i32 addrspace(1)* inttoptr (i32 1392 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add122 = add nsw i32 %76, 32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.cond24, !llvm.loop !6
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %77 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %78 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins124 = insertelement <5 x i32> %78, i32 %77, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins124, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %79 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins125 = insertelement <5 x i32> %79, i32 %77, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins125, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %80 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %81 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins126 = insertelement <5 x i32> %81, i32 %80, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins126, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %82 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins127 = insertelement <5 x i32> %82, i32 %80, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins127, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %83 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %84 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins128 = insertelement <5 x i32> %84, i32 %83, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins128, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %85 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins129 = insertelement <5 x i32> %85, i32 %83, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins129, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %86 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %87 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins130 = insertelement <5 x i32> %87, i32 %86, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins130, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %88 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins131 = insertelement <5 x i32> %88, i32 %86, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins131, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %89 = load i32, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %89, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %90 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.cond132
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %storemerge281 = phi i32 [ %90, %for.end123 ], [ %add275, %for.inc274 ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %storemerge281, i32 addrspace(1)* inttoptr (i32 1476 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %91 = load i32, i32 addrspace(1)* inttoptr (i32 1068 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %cmp133 = icmp slt i32 %storemerge281, %91
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %cmp133, label %for.body134, label %for.end276
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %92 = load i32, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %93 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins135 = insertelement <5 x i32> %93, i32 %92, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins135, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add136 = add nsw i32 %92, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %94 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins137 = insertelement <5 x i32> %94, i32 %add136, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins137, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %95 = load i32, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add138 = add nsw i32 %95, 2
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %96 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins139 = insertelement <5 x i32> %96, i32 %add138, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins139, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add140 = add nsw i32 %95, 3
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %97 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins141 = insertelement <5 x i32> %97, i32 %add140, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins141, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 0, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 0, i32 addrspace(1)* inttoptr (i32 1484 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %98 = load i32, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %99 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins142 = insertelement <5 x i32> %99, i32 %98, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %100 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins142, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add144 = add nsw i32 %98, 32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins145 = insertelement <5 x i32> %vecins142, i32 %add144, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %101 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins145, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add147 = add nsw i32 %98, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins148 = insertelement <5 x i32> %vecins145, i32 %add147, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %102 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins148, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add150 = add nsw i32 %98, 96
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins151 = insertelement <5 x i32> %vecins148, i32 %add150, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins151, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %103 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins151, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %100, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %101, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %102, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %103, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %104 = load i32, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add152 = add nsw i32 %104, 128
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add152, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 0, i32 addrspace(1)* inttoptr (i32 1488 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 4, i32 addrspace(1)* inttoptr (i32 1492 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 8, i32 addrspace(1)* inttoptr (i32 1496 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 12, i32 addrspace(1)* inttoptr (i32 1500 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %105 = load i32, i32 addrspace(1)* inttoptr (i32 1336 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %106 = load i32, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %sub153 = sub nsw i32 %105, %106
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %sub153, i32 addrspace(1)* inttoptr (i32 1504 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 0, i32 addrspace(1)* inttoptr (i32 1508 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %do.body
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %107 = load i32, i32 addrspace(1)* inttoptr (i32 1488 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %108 = call i32 @llvm.tpc.ld.l.i32(i32 %107, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %108, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add155 = add nsw i32 %107, 16
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add155, i32 addrspace(1)* inttoptr (i32 1488 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %109 = load i32, i32 addrspace(1)* inttoptr (i32 1492 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %110 = call i32 @llvm.tpc.ld.l.i32(i32 %109, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %110, i32 addrspace(1)* inttoptr (i32 1516 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add156 = add nsw i32 %109, 16
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add156, i32 addrspace(1)* inttoptr (i32 1492 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %111 = load i32, i32 addrspace(1)* inttoptr (i32 1496 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %112 = call i32 @llvm.tpc.ld.l.i32(i32 %111, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %112, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add157 = add nsw i32 %111, 16
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add157, i32 addrspace(1)* inttoptr (i32 1496 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %113 = load i32, i32 addrspace(1)* inttoptr (i32 1500 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %114 = call i32 @llvm.tpc.ld.l.i32(i32 %113, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %114, i32 addrspace(1)* inttoptr (i32 1524 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add158 = add nsw i32 %113, 16
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add158, i32 addrspace(1)* inttoptr (i32 1500 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %115 = load i32, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %116 = load i32, i32 addrspace(1)* inttoptr (i32 1516 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %117 = call i32 @llvm.tpc.max.i32.i32.i32.i1(i32 %115, i32 %116, i8 2, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %118 = load i32, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %119 = load i32, i32 addrspace(1)* inttoptr (i32 1524 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %120 = call i32 @llvm.tpc.max.i32.i32.i32.i1(i32 %118, i32 %119, i8 2, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %121 = call i32 @llvm.tpc.max.i32.i32.i32.i1(i32 %117, i32 %120, i8 2, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %121, i32 addrspace(1)* inttoptr (i32 1528 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %122 = load i32, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %123 = load i32, i32 addrspace(1)* inttoptr (i32 1516 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add159 = add nsw i32 %122, %123
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add159, i32 addrspace(1)* inttoptr (i32 1532 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %124 = load i32, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %125 = load i32, i32 addrspace(1)* inttoptr (i32 1524 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add160 = add nsw i32 %124, %125
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add160, i32 addrspace(1)* inttoptr (i32 1536 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %126 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %127 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins161 = insertelement <5 x i32> %127, i32 %126, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins161, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %128 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins162 = insertelement <5 x i32> %128, i32 %126, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins162, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %129 = load i32, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add164 = add nsw i32 %126, %129
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins165 = insertelement <5 x i32> %vecins162, i32 %add164, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins165, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %130 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %131 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins166 = insertelement <5 x i32> %131, i32 %130, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins166, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %132 = load i32, i32 addrspace(1)* inttoptr (i32 1532 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add168 = add nsw i32 %130, %132
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins169 = insertelement <5 x i32> %vecins166, i32 %add168, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins169, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %133 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %134 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins170 = insertelement <5 x i32> %134, i32 %133, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins170, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %135 = load i32, i32 addrspace(1)* inttoptr (i32 1532 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %136 = load i32, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add171 = add nsw i32 %135, %136
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add173 = add nsw i32 %133, %add171
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins174 = insertelement <5 x i32> %vecins170, i32 %add173, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins174, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %137 = load i32, i32 addrspace(1)* inttoptr (i32 1536 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add175 = add nsw i32 %135, %137
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add175, i32 addrspace(1)* inttoptr (i32 1540 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %138 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add176 = add nsw i32 %138, %add175
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add176, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %139 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %140 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %139, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext177 = extractelement <5 x i32> %139, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add178 = add nsw i32 %vecext177, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins179 = insertelement <5 x i32> %139, i32 %add178, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins179, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %141 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %142 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %141, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext180 = extractelement <5 x i32> %141, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add181 = add nsw i32 %vecext180, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins182 = insertelement <5 x i32> %141, i32 %add181, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins182, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %143 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %144 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %143, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext183 = extractelement <5 x i32> %143, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add184 = add nsw i32 %vecext183, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins185 = insertelement <5 x i32> %143, i32 %add184, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins185, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %145 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %146 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %145, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext186 = extractelement <5 x i32> %145, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add187 = add nsw i32 %vecext186, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins188 = insertelement <5 x i32> %145, i32 %add187, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins188, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> zeroinitializer, <64 x float> addrspace(2)* inttoptr (i32 1024 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> zeroinitializer, <64 x float> addrspace(2)* inttoptr (i32 1280 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> zeroinitializer, <64 x float> addrspace(2)* inttoptr (i32 1536 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> zeroinitializer, <64 x float> addrspace(2)* inttoptr (i32 1792 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 0, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %do.body189
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %indicesCoordPtr0.0.in = phi i8 addrspace(3)* [ %140, %do.body ], [ %162, %do.cond ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %indicesCoordPtr1.0.in = phi i8 addrspace(3)* [ %142, %do.body ], [ %164, %do.cond ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %indicesCoordPtr2.0.in = phi i8 addrspace(3)* [ %144, %do.body ], [ %166, %do.cond ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %indicesCoordPtr3.0.in = phi i8 addrspace(3)* [ %146, %do.body ], [ %168, %do.cond ]
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %147 = load i32, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %148 = load i32, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %149 = call i1 @llvm.tpc.cmp.less.i1.i32.i32.i1(i32 %147, i32 %148, i8 2, i32 0, i1 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %conv = zext i1 %149 to i8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i8 %conv, i8 addrspace(1)* inttoptr (i32 1548 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %150 = load i32, i32 addrspace(1)* inttoptr (i32 1516 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %151 = call i1 @llvm.tpc.cmp.less.i1.i32.i32.i1(i32 %147, i32 %150, i8 2, i32 0, i1 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %conv190 = zext i1 %151 to i8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i8 %conv190, i8 addrspace(1)* inttoptr (i32 1552 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %152 = load i32, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %153 = load i32, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %154 = call i1 @llvm.tpc.cmp.less.i1.i32.i32.i1(i32 %152, i32 %153, i8 2, i32 0, i1 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %conv191 = zext i1 %154 to i8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i8 %conv191, i8 addrspace(1)* inttoptr (i32 1556 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %155 = load i32, i32 addrspace(1)* inttoptr (i32 1524 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %156 = call i1 @llvm.tpc.cmp.less.i1.i32.i32.i1(i32 %152, i32 %155, i8 2, i32 0, i1 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %conv192 = zext i1 %156 to i8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i8 %conv192, i8 addrspace(1)* inttoptr (i32 1560 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %157 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %indicesCoordPtr0.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %157, i32 addrspace(1)* inttoptr (i32 1564 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %158 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %indicesCoordPtr1.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %158, i32 addrspace(1)* inttoptr (i32 1568 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %159 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %indicesCoordPtr2.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %159, i32 addrspace(1)* inttoptr (i32 1572 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %160 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %indicesCoordPtr3.0.in, i32 0, i32 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %160, i32 addrspace(1)* inttoptr (i32 1576 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %161 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %162 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %161, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext193 = extractelement <5 x i32> %161, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add194 = add nsw i32 %vecext193, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins195 = insertelement <5 x i32> %161, i32 %add194, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins195, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %163 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %164 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %163, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext196 = extractelement <5 x i32> %163, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add197 = add nsw i32 %vecext196, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins198 = insertelement <5 x i32> %163, i32 %add197, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins198, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %165 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %166 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %165, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext199 = extractelement <5 x i32> %165, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add200 = add nsw i32 %vecext199, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins201 = insertelement <5 x i32> %165, i32 %add200, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins201, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %167 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %168 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %167, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext202 = extractelement <5 x i32> %167, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add203 = add nsw i32 %vecext202, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins204 = insertelement <5 x i32> %167, i32 %add203, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins204, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %169 = load i32, i32 addrspace(1)* inttoptr (i32 1564 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %170 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins205 = insertelement <5 x i32> %170, i32 %169, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins205, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %171 = load i32, i32 addrspace(1)* inttoptr (i32 1568 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %172 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins206 = insertelement <5 x i32> %172, i32 %171, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins206, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %173 = load i32, i32 addrspace(1)* inttoptr (i32 1572 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %174 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins207 = insertelement <5 x i32> %174, i32 %173, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins207, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %175 = load i32, i32 addrspace(1)* inttoptr (i32 1576 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %176 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins208 = insertelement <5 x i32> %176, i32 %175, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins208, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %177 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %178 = call <64 x float> @llvm.tpc.ld.tnsr.v64f32.i1(<5 x i32> %177, i8 0, i32 0, <64 x float> undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> %178, <64 x float> addrspace(2)* null, align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %179 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %180 = call <64 x float> @llvm.tpc.ld.tnsr.v64f32.i1(<5 x i32> %179, i8 0, i32 0, <64 x float> undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> %180, <64 x float> addrspace(2)* inttoptr (i32 256 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %181 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %182 = call <64 x float> @llvm.tpc.ld.tnsr.v64f32.i1(<5 x i32> %181, i8 0, i32 0, <64 x float> undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> %182, <64 x float> addrspace(2)* inttoptr (i32 512 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %183 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %184 = call <64 x float> @llvm.tpc.ld.tnsr.v64f32.i1(<5 x i32> %183, i8 0, i32 0, <64 x float> undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> %184, <64 x float> addrspace(2)* inttoptr (i32 768 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %185 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1024 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %186 = load <64 x float>, <64 x float> addrspace(2)* null, align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %187 = load i8, i8 addrspace(1)* inttoptr (i32 1548 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %tobool = icmp ne i8 %187, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %188 = call <64 x float> @llvm.tpc.add.v64f32.v64f32.v64f32.i1(<64 x float> %185, <64 x float> %186, i8 0, i32 0, <64 x float> %185, i1 %tobool, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> %188, <64 x float> addrspace(2)* inttoptr (i32 1024 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %189 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1280 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %190 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 256 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %191 = load i8, i8 addrspace(1)* inttoptr (i32 1552 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %tobool209 = icmp ne i8 %191, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %192 = call <64 x float> @llvm.tpc.add.v64f32.v64f32.v64f32.i1(<64 x float> %189, <64 x float> %190, i8 0, i32 0, <64 x float> %189, i1 %tobool209, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> %192, <64 x float> addrspace(2)* inttoptr (i32 1280 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %193 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1536 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %194 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 512 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %195 = load i8, i8 addrspace(1)* inttoptr (i32 1556 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %tobool210 = icmp ne i8 %195, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %196 = call <64 x float> @llvm.tpc.add.v64f32.v64f32.v64f32.i1(<64 x float> %193, <64 x float> %194, i8 0, i32 0, <64 x float> %193, i1 %tobool210, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> %196, <64 x float> addrspace(2)* inttoptr (i32 1536 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %197 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1792 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %198 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 768 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %199 = load i8, i8 addrspace(1)* inttoptr (i32 1560 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %tobool211 = icmp ne i8 %199, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %200 = call <64 x float> @llvm.tpc.add.v64f32.v64f32.v64f32.i1(<64 x float> %197, <64 x float> %198, i8 0, i32 0, <64 x float> %197, i1 %tobool211, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <64 x float> %200, <64 x float> addrspace(2)* inttoptr (i32 1792 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %201 = load i32, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add212 = add nsw i32 %201, 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add212, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %do.cond
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %202 = load i32, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %203 = load i32, i32 addrspace(1)* inttoptr (i32 1528 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %cmp213 = icmp slt i32 %202, %203
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %cmp213, label %do.body189, label %do.end, !llvm.loop !7
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %204 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %205 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1024 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: call void @llvm.tpc.st.tnsr.v64f32(<5 x i32> %204, i8 4, <64 x float> %205, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext215 = extractelement <5 x i32> %204, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add216 = add nsw i32 %vecext215, 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins217 = insertelement <5 x i32> %204, i32 %add216, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins217, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %206 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %207 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1280 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: call void @llvm.tpc.st.tnsr.v64f32(<5 x i32> %206, i8 4, <64 x float> %207, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext218 = extractelement <5 x i32> %206, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add219 = add nsw i32 %vecext218, 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins220 = insertelement <5 x i32> %206, i32 %add219, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins220, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %208 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %209 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1536 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: call void @llvm.tpc.st.tnsr.v64f32(<5 x i32> %208, i8 4, <64 x float> %209, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext221 = extractelement <5 x i32> %208, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add222 = add nsw i32 %vecext221, 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins223 = insertelement <5 x i32> %208, i32 %add222, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins223, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %210 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %211 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1792 to <64 x float> addrspace(2)*), align 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 2 for instruction: call void @llvm.tpc.st.tnsr.v64f32(<5 x i32> %210, i8 4, <64 x float> %211, i32 0, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext224 = extractelement <5 x i32> %210, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add225 = add nsw i32 %vecext224, 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins226 = insertelement <5 x i32> %210, i32 %add225, i32 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins226, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %212 = load i32, i32 addrspace(1)* inttoptr (i32 1540 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %213 = load i32, i32 addrspace(1)* inttoptr (i32 1484 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add227 = add nsw i32 %213, %212
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add227, i32 addrspace(1)* inttoptr (i32 1484 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add228 = add nsw i32 %add227, 96
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %214 = load i32, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 3 for instruction: %215 = call i1 @llvm.tpc.cmp.geq.i1.i32.i32.i1(i32 %add228, i32 %214, i8 2, i32 0, i1 undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %conv229 = zext i1 %215 to i8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i8 %conv229, i8 addrspace(1)* inttoptr (i32 1580 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %216 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %217 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins230 = insertelement <5 x i32> %217, i32 %216, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %218 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins230, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add232 = add nsw i32 %216, 32
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins233 = insertelement <5 x i32> %vecins230, i32 %add232, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %219 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins233, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add235 = add nsw i32 %216, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins236 = insertelement <5 x i32> %vecins233, i32 %add235, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %220 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins236, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add238 = add nsw i32 %216, 96
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins239 = insertelement <5 x i32> %vecins236, i32 %add238, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins239, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 6 for instruction: %221 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins239, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %222 = load i8, i8 addrspace(1)* inttoptr (i32 1580 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %tobool240 = icmp ne i8 %222, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %218, i32 0, i1 %tobool240, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %tobool241 = icmp ne i8 %222, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %219, i32 0, i1 %tobool241, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %tobool242 = icmp ne i8 %222, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %220, i32 0, i1 %tobool242, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %223 = load i8, i8 addrspace(1)* inttoptr (i32 1580 to i8 addrspace(1)*), align 1
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %tobool243 = icmp ne i8 %223, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: call void @llvm.tpc.prefetch(i8 addrspace(3)* %221, i32 0, i1 %tobool243, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %224 = load i32, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %tobool244 = icmp ne i8 %223, 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %225 = call i32 @llvm.tpc.add.i32.i32.i32.i1(i32 %224, i32 32, i8 2, i32 0, i32 %224, i1 %tobool244, i1 false)
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %225, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %226 = load i32, i32 addrspace(1)* inttoptr (i32 1508 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add245 = add nsw i32 %226, 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %add245, i32 addrspace(1)* inttoptr (i32 1508 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %do.cond246
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %227 = load i32, i32 addrspace(1)* inttoptr (i32 1508 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %228 = load i32, i32 addrspace(1)* inttoptr (i32 1504 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %cmp247 = icmp slt i32 %227, %228
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br i1 %cmp247, label %do.body, label %do.end249, !llvm.loop !8
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %229 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext250 = extractelement <5 x i32> %229, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add251 = add nsw i32 %vecext250, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins252 = insertelement <5 x i32> %229, i32 %add251, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins252, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %230 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext253 = extractelement <5 x i32> %230, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add254 = add nsw i32 %vecext253, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins255 = insertelement <5 x i32> %230, i32 %add254, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins255, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %231 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext256 = extractelement <5 x i32> %231, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add257 = add nsw i32 %vecext256, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins258 = insertelement <5 x i32> %231, i32 %add257, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins258, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %232 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext259 = extractelement <5 x i32> %232, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add260 = add nsw i32 %vecext259, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins261 = insertelement <5 x i32> %232, i32 %add260, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins261, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %233 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext262 = extractelement <5 x i32> %233, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add263 = add nsw i32 %vecext262, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins264 = insertelement <5 x i32> %233, i32 %add263, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins264, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %234 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext265 = extractelement <5 x i32> %234, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add266 = add nsw i32 %vecext265, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins267 = insertelement <5 x i32> %234, i32 %add266, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins267, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %235 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext268 = extractelement <5 x i32> %235, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add269 = add nsw i32 %vecext268, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins270 = insertelement <5 x i32> %235, i32 %add269, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins270, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %236 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecext271 = extractelement <5 x i32> %236, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add272 = add nsw i32 %vecext271, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %vecins273 = insertelement <5 x i32> %236, i32 %add272, i32 0
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store <5 x i32> %vecins273, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.inc274
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %237 = load i32, i32 addrspace(1)* inttoptr (i32 1476 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add275 = add nsw i32 %237, 64
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.cond132, !llvm.loop !9
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %238 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: store i32 %238, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.inc277
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %239 = load i32, i32 addrspace(1)* inttoptr (i32 1348 to i32 addrspace(1)*), align 4
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 4 for instruction: %add278 = add nsw i32 %239, 256
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: br label %for.cond, !llvm.loop !10
; LATENCY-NEXT:  Cost Model: Found an estimated cost of 1 for instruction: ret void
;
entry:
  %0 = call <5 x i32> @llvm.tpc.get.index.space.offset()
  store <5 x i32> %0, <5 x i32> addrspace(1)* inttoptr (i32 1024 to <5 x i32> addrspace(1)*), align 4
  %1 = call <5 x i32> @llvm.tpc.get.index.space.size()
  %add = add <5 x i32> %1, %0
  store <5 x i32> %add, <5 x i32> addrspace(1)* inttoptr (i32 1044 to <5 x i32> addrspace(1)*), align 4
  %vecext = extractelement <5 x i32> %0, i32 0
  %mul = shl nsw i32 %vecext, 6
  store i32 %mul, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
  %vecext1 = extractelement <5 x i32> %add, i32 0
  %mul2 = shl nsw i32 %vecext1, 6
  store i32 %mul2, i32 addrspace(1)* inttoptr (i32 1068 to i32 addrspace(1)*), align 4
  %2 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> zeroinitializer, i8 3, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %3 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %2, i32 0, i32 undef, i1 true, i1 false)
  store i32 %3, i32 addrspace(1)* inttoptr (i32 1072 to i32 addrspace(1)*), align 4
  %shr = ashr i32 %3, 3
  %4 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1024 to <5 x i32> addrspace(1)*), align 4
  %vecext3 = extractelement <5 x i32> %4, i32 1
  %mul4 = mul nsw i32 %vecext3, %shr
  %5 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1044 to <5 x i32> addrspace(1)*), align 4
  %vecext5 = extractelement <5 x i32> %5, i32 1
  %mul6 = mul nsw i32 %vecext5, %shr
  %6 = and i32 %mul4, -32
  store i32 %6, i32 addrspace(1)* inttoptr (i32 1076 to i32 addrspace(1)*), align 4
  %add8 = add nsw i32 %mul6, 31
  %7 = and i32 %add8, -32
  store i32 %7, i32 addrspace(1)* inttoptr (i32 1080 to i32 addrspace(1)*), align 4
  %8 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1044 to <5 x i32> addrspace(1)*), align 4
  %vecext11 = extractelement <5 x i32> %8, i32 1
  %cmp = icmp eq i32 %vecext11, 8
  br i1 %cmp, label %if.then, label %if.end

if.then:                                          ; preds = %entry
  %9 = load i32, i32 addrspace(1)* inttoptr (i32 1072 to i32 addrspace(1)*), align 4
  store i32 %9, i32 addrspace(1)* inttoptr (i32 1080 to i32 addrspace(1)*), align 4
  br label %if.end

if.end:                                           ; preds = %if.then, %entry
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
  store <5 x i32> zeroinitializer, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
  store i32 0, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
  store i32 0, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
  %10 = load i32, i32 addrspace(1)* inttoptr (i32 1076 to i32 addrspace(1)*), align 4
  store i32 %10, i32 addrspace(1)* inttoptr (i32 1336 to i32 addrspace(1)*), align 4
  store i32 0, i32 addrspace(1)* inttoptr (i32 1340 to i32 addrspace(1)*), align 4
  %11 = load i32, i32 addrspace(1)* inttoptr (i32 1080 to i32 addrspace(1)*), align 4
  %sub = sub nsw i32 %11, %10
  store i32 %sub, i32 addrspace(1)* inttoptr (i32 1344 to i32 addrspace(1)*), align 4
  br label %for.cond

for.cond:                                         ; preds = %for.inc277, %if.end
  %storemerge = phi i32 [ %10, %if.end ], [ %add278, %for.inc277 ]
  store i32 %storemerge, i32 addrspace(1)* inttoptr (i32 1348 to i32 addrspace(1)*), align 4
  %12 = load i32, i32 addrspace(1)* inttoptr (i32 1080 to i32 addrspace(1)*), align 4
  %cmp12 = icmp slt i32 %storemerge, %12
  br i1 %cmp12, label %for.body, label %for.end279

for.body:                                         ; preds = %for.cond
  %13 = load i32, i32 addrspace(1)* inttoptr (i32 1344 to i32 addrspace(1)*), align 4
  %14 = call i32 @llvm.tpc.min.i32.i32.i32.i1(i32 %13, i32 256, i8 2, i32 0, i32 undef, i1 true, i1 false)
  store i32 %14, i32 addrspace(1)* inttoptr (i32 1340 to i32 addrspace(1)*), align 4
  %sub13 = add nsw i32 %13, -256
  store i32 %sub13, i32 addrspace(1)* inttoptr (i32 1344 to i32 addrspace(1)*), align 4
  %15 = load i32, i32 addrspace(1)* inttoptr (i32 1336 to i32 addrspace(1)*), align 4
  store i32 %15, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
  %add14 = add nsw i32 %15, %14
  store i32 %add14, i32 addrspace(1)* inttoptr (i32 1336 to i32 addrspace(1)*), align 4
  store i32 0, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %vecinit18 = insertelement <5 x i32> <i32 undef, i32 0, i32 0, i32 0, i32 0>, i32 %15, i32 0
  store <5 x i32> %vecinit18, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %vecinit23 = insertelement <5 x i32> <i32 undef, i32 0, i32 0, i32 0, i32 0>, i32 %15, i32 0
  store <5 x i32> %vecinit23, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
  br label %for.cond24

for.cond24:                                       ; preds = %for.inc121, %for.body
  %storemerge280 = phi i32 [ 0, %for.body ], [ %add122, %for.inc121 ]
  store i32 %storemerge280, i32 addrspace(1)* inttoptr (i32 1392 to i32 addrspace(1)*), align 4
  %16 = load i32, i32 addrspace(1)* inttoptr (i32 1340 to i32 addrspace(1)*), align 4
  %cmp25 = icmp slt i32 %storemerge280, %16
  br i1 %cmp25, label %for.body26, label %for.end123

for.body26:                                       ; preds = %for.cond24
  %17 = load i32, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
  %18 = load i32, i32 addrspace(1)* inttoptr (i32 1392 to i32 addrspace(1)*), align 4
  %add27 = add nsw i32 %17, %18
  %add28 = add nsw i32 %add27, 32
  store i32 %add28, i32 addrspace(1)* inttoptr (i32 1400 to i32 addrspace(1)*), align 4
  %19 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
  %20 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %19, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext29 = extractelement <5 x i32> %19, i32 0
  %add30 = add nsw i32 %vecext29, 32
  %vecins = insertelement <5 x i32> %19, i32 %add30, i32 0
  %21 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add32 = add nsw i32 %vecext29, 64
  %vecins33 = insertelement <5 x i32> %vecins, i32 %add32, i32 0
  %22 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins33, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add35 = add nsw i32 %vecext29, 96
  %vecins36 = insertelement <5 x i32> %vecins33, i32 %add35, i32 0
  %23 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins36, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %sub38 = add nsw i32 %vecext29, 32
  %vecins39 = insertelement <5 x i32> %vecins36, i32 %sub38, i32 0
  store <5 x i32> %vecins39, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %20, i32 0, i1 true, i1 false)
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %21, i32 0, i1 true, i1 false)
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %22, i32 0, i1 true, i1 false)
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %23, i32 0, i1 true, i1 false)
  %24 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %25 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %24, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %26 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %25, i32 0, i32 undef, i1 true, i1 false)
  store i32 %26, i32 addrspace(1)* inttoptr (i32 1396 to i32 addrspace(1)*), align 4
  %vecext40 = extractelement <5 x i32> %24, i32 0
  %add41 = add nsw i32 %vecext40, 1
  %vecins42 = insertelement <5 x i32> %24, i32 %add41, i32 0
  store <5 x i32> %vecins42, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %27 = load i32, i32 addrspace(1)* inttoptr (i32 1392 to i32 addrspace(1)*), align 4
  %cmp43 = icmp eq i32 %27, 0
  br i1 %cmp43, label %if.then44, label %if.end45

if.then44:                                        ; preds = %for.body26
  %28 = load i32, i32 addrspace(1)* inttoptr (i32 1396 to i32 addrspace(1)*), align 4
  store i32 %28, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
  br label %if.end45

if.end45:                                         ; preds = %if.then44, %for.body26
  %29 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %30 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %29, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext46 = extractelement <5 x i32> %29, i32 0
  %add47 = add nsw i32 %vecext46, 1
  %vecins48 = insertelement <5 x i32> %29, i32 %add47, i32 0
  %31 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins48, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add50 = add nsw i32 %vecext46, 2
  %vecins51 = insertelement <5 x i32> %vecins48, i32 %add50, i32 0
  %32 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins51, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add53 = add nsw i32 %vecext46, 3
  %vecins54 = insertelement <5 x i32> %vecins51, i32 %add53, i32 0
  %33 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins54, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add56 = add nsw i32 %vecext46, 4
  %vecins57 = insertelement <5 x i32> %vecins54, i32 %add56, i32 0
  %34 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins57, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add59 = add nsw i32 %vecext46, 5
  %vecins60 = insertelement <5 x i32> %vecins57, i32 %add59, i32 0
  %35 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins60, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add62 = add nsw i32 %vecext46, 6
  %vecins63 = insertelement <5 x i32> %vecins60, i32 %add62, i32 0
  %36 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins63, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add65 = add nsw i32 %vecext46, 7
  %vecins66 = insertelement <5 x i32> %vecins63, i32 %add65, i32 0
  %37 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins66, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add68 = add nsw i32 %vecext46, 8
  %vecins69 = insertelement <5 x i32> %vecins66, i32 %add68, i32 0
  store <5 x i32> %vecins69, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  br label %for.cond70

for.cond70:                                       ; preds = %for.inc, %if.end45
  %storemerge282 = phi i32 [ 0, %if.end45 ], [ %add119, %for.inc ]
  %prt6.0.in = phi i8 addrspace(3)* [ %36, %if.end45 ], [ %52, %for.inc ]
  %prt5.0.in = phi i8 addrspace(3)* [ %35, %if.end45 ], [ %50, %for.inc ]
  %prt4.0.in = phi i8 addrspace(3)* [ %34, %if.end45 ], [ %48, %for.inc ]
  %prt3.0.in = phi i8 addrspace(3)* [ %33, %if.end45 ], [ %46, %for.inc ]
  %prt2.0.in = phi i8 addrspace(3)* [ %32, %if.end45 ], [ %44, %for.inc ]
  %prt1.0.in = phi i8 addrspace(3)* [ %31, %if.end45 ], [ %42, %for.inc ]
  %prt0.0.in = phi i8 addrspace(3)* [ %30, %if.end45 ], [ %40, %for.inc ]
  %prt7.0.in = phi i8 addrspace(3)* [ %37, %if.end45 ], [ %54, %for.inc ]
  store i32 %storemerge282, i32 addrspace(1)* inttoptr (i32 1404 to i32 addrspace(1)*), align 4
  %cmp71 = icmp slt i32 %storemerge282, 32
  br i1 %cmp71, label %for.body72, label %for.end

for.body72:                                       ; preds = %for.cond70
  %38 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt0.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %38, i32 addrspace(1)* inttoptr (i32 1408 to i32 addrspace(1)*), align 4
  %39 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %40 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %39, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext73 = extractelement <5 x i32> %39, i32 0
  %add74 = add nsw i32 %vecext73, 1
  %vecins75 = insertelement <5 x i32> %39, i32 %add74, i32 0
  store <5 x i32> %vecins75, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %41 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt1.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %41, i32 addrspace(1)* inttoptr (i32 1412 to i32 addrspace(1)*), align 4
  %42 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins75, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add77 = add nsw i32 %vecext73, 2
  %vecins78 = insertelement <5 x i32> %vecins75, i32 %add77, i32 0
  store <5 x i32> %vecins78, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %43 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt2.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %43, i32 addrspace(1)* inttoptr (i32 1416 to i32 addrspace(1)*), align 4
  %44 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins78, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add80 = add nsw i32 %vecext73, 3
  %vecins81 = insertelement <5 x i32> %vecins78, i32 %add80, i32 0
  store <5 x i32> %vecins81, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %45 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt3.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %45, i32 addrspace(1)* inttoptr (i32 1420 to i32 addrspace(1)*), align 4
  %46 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins81, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add83 = add nsw i32 %vecext73, 4
  %vecins84 = insertelement <5 x i32> %vecins81, i32 %add83, i32 0
  store <5 x i32> %vecins84, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %47 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt4.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %47, i32 addrspace(1)* inttoptr (i32 1424 to i32 addrspace(1)*), align 4
  %48 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins84, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add86 = add nsw i32 %vecext73, 5
  %vecins87 = insertelement <5 x i32> %vecins84, i32 %add86, i32 0
  store <5 x i32> %vecins87, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %49 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt5.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %49, i32 addrspace(1)* inttoptr (i32 1428 to i32 addrspace(1)*), align 4
  %50 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins87, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add89 = add nsw i32 %vecext73, 6
  %vecins90 = insertelement <5 x i32> %vecins87, i32 %add89, i32 0
  store <5 x i32> %vecins90, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %51 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt6.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %51, i32 addrspace(1)* inttoptr (i32 1432 to i32 addrspace(1)*), align 4
  %52 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins90, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add92 = add nsw i32 %vecext73, 7
  %vecins93 = insertelement <5 x i32> %vecins90, i32 %add92, i32 0
  store <5 x i32> %vecins93, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %53 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %prt7.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %53, i32 addrspace(1)* inttoptr (i32 1436 to i32 addrspace(1)*), align 4
  %54 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins93, i8 2, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add95 = add nsw i32 %vecext73, 8
  %vecins96 = insertelement <5 x i32> %vecins93, i32 %add95, i32 0
  store <5 x i32> %vecins96, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %55 = load i32, i32 addrspace(1)* inttoptr (i32 1408 to i32 addrspace(1)*), align 4
  %56 = load i32, i32 addrspace(1)* inttoptr (i32 1396 to i32 addrspace(1)*), align 4
  %sub97 = sub nsw i32 %55, %56
  store i32 %sub97, i32 addrspace(1)* inttoptr (i32 1440 to i32 addrspace(1)*), align 4
  %57 = load i32, i32 addrspace(1)* inttoptr (i32 1412 to i32 addrspace(1)*), align 4
  %sub98 = sub nsw i32 %57, %55
  store i32 %sub98, i32 addrspace(1)* inttoptr (i32 1444 to i32 addrspace(1)*), align 4
  %58 = load i32, i32 addrspace(1)* inttoptr (i32 1416 to i32 addrspace(1)*), align 4
  %sub99 = sub nsw i32 %58, %57
  store i32 %sub99, i32 addrspace(1)* inttoptr (i32 1448 to i32 addrspace(1)*), align 4
  %59 = load i32, i32 addrspace(1)* inttoptr (i32 1420 to i32 addrspace(1)*), align 4
  %sub100 = sub nsw i32 %59, %58
  store i32 %sub100, i32 addrspace(1)* inttoptr (i32 1452 to i32 addrspace(1)*), align 4
  %60 = load i32, i32 addrspace(1)* inttoptr (i32 1424 to i32 addrspace(1)*), align 4
  %sub101 = sub nsw i32 %60, %59
  store i32 %sub101, i32 addrspace(1)* inttoptr (i32 1456 to i32 addrspace(1)*), align 4
  %61 = load i32, i32 addrspace(1)* inttoptr (i32 1428 to i32 addrspace(1)*), align 4
  %sub102 = sub nsw i32 %61, %60
  store i32 %sub102, i32 addrspace(1)* inttoptr (i32 1460 to i32 addrspace(1)*), align 4
  %62 = load i32, i32 addrspace(1)* inttoptr (i32 1432 to i32 addrspace(1)*), align 4
  %sub103 = sub nsw i32 %62, %61
  store i32 %sub103, i32 addrspace(1)* inttoptr (i32 1464 to i32 addrspace(1)*), align 4
  %63 = load i32, i32 addrspace(1)* inttoptr (i32 1436 to i32 addrspace(1)*), align 4
  %sub104 = sub nsw i32 %63, %62
  store i32 %sub104, i32 addrspace(1)* inttoptr (i32 1468 to i32 addrspace(1)*), align 4
  store i32 %63, i32 addrspace(1)* inttoptr (i32 1396 to i32 addrspace(1)*), align 4
  %64 = load i32, i32 addrspace(1)* inttoptr (i32 1440 to i32 addrspace(1)*), align 4
  %65 = load i32, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %inc = add nsw i32 %65, 1
  store i32 %inc, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %arrayidx = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %65
  store volatile i32 %64, i32 addrspace(1)* %arrayidx, align 4
  %66 = load i32, i32 addrspace(1)* inttoptr (i32 1444 to i32 addrspace(1)*), align 4
  %inc105 = add nsw i32 %65, 2
  store i32 %inc105, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %arrayidx106 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc
  store volatile i32 %66, i32 addrspace(1)* %arrayidx106, align 4
  %67 = load i32, i32 addrspace(1)* inttoptr (i32 1448 to i32 addrspace(1)*), align 4
  %inc107 = add nsw i32 %65, 3
  store i32 %inc107, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %arrayidx108 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc105
  store volatile i32 %67, i32 addrspace(1)* %arrayidx108, align 4
  %68 = load i32, i32 addrspace(1)* inttoptr (i32 1452 to i32 addrspace(1)*), align 4
  %inc109 = add nsw i32 %65, 4
  store i32 %inc109, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %arrayidx110 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc107
  store volatile i32 %68, i32 addrspace(1)* %arrayidx110, align 4
  %69 = load i32, i32 addrspace(1)* inttoptr (i32 1456 to i32 addrspace(1)*), align 4
  %inc111 = add nsw i32 %65, 5
  store i32 %inc111, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %arrayidx112 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc109
  store volatile i32 %69, i32 addrspace(1)* %arrayidx112, align 4
  %70 = load i32, i32 addrspace(1)* inttoptr (i32 1460 to i32 addrspace(1)*), align 4
  %inc113 = add nsw i32 %65, 6
  store i32 %inc113, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %arrayidx114 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc111
  store volatile i32 %70, i32 addrspace(1)* %arrayidx114, align 4
  %71 = load i32, i32 addrspace(1)* inttoptr (i32 1464 to i32 addrspace(1)*), align 4
  %inc115 = add nsw i32 %65, 7
  store i32 %inc115, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %arrayidx116 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc113
  store volatile i32 %71, i32 addrspace(1)* %arrayidx116, align 4
  %72 = load i32, i32 addrspace(1)* inttoptr (i32 1468 to i32 addrspace(1)*), align 4
  %inc117 = add nsw i32 %65, 8
  store i32 %inc117, i32 addrspace(1)* inttoptr (i32 1328 to i32 addrspace(1)*), align 4
  %arrayidx118 = getelementptr inbounds [256 x i32], [256 x i32] addrspace(1)* null, i32 0, i32 %inc115
  store volatile i32 %72, i32 addrspace(1)* %arrayidx118, align 4
  br label %for.inc

for.inc:                                          ; preds = %for.body72
  %73 = load i32, i32 addrspace(1)* inttoptr (i32 1404 to i32 addrspace(1)*), align 4
  %add119 = add nsw i32 %73, 8
  br label %for.cond70, !llvm.loop !4

for.end:                                          ; preds = %for.cond70
  %74 = load i32, i32 addrspace(1)* inttoptr (i32 1400 to i32 addrspace(1)*), align 4
  %75 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  %vecins120 = insertelement <5 x i32> %75, i32 %74, i32 0
  store <5 x i32> %vecins120, <5 x i32> addrspace(1)* inttoptr (i32 1352 to <5 x i32> addrspace(1)*), align 4
  br label %for.inc121

for.inc121:                                       ; preds = %for.end
  %76 = load i32, i32 addrspace(1)* inttoptr (i32 1392 to i32 addrspace(1)*), align 4
  %add122 = add nsw i32 %76, 32
  br label %for.cond24, !llvm.loop !6

for.end123:                                       ; preds = %for.cond24
  %77 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
  %78 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
  %vecins124 = insertelement <5 x i32> %78, i32 %77, i32 0
  store <5 x i32> %vecins124, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
  %79 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
  %vecins125 = insertelement <5 x i32> %79, i32 %77, i32 0
  store <5 x i32> %vecins125, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
  %80 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
  %81 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
  %vecins126 = insertelement <5 x i32> %81, i32 %80, i32 0
  store <5 x i32> %vecins126, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
  %82 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
  %vecins127 = insertelement <5 x i32> %82, i32 %80, i32 0
  store <5 x i32> %vecins127, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
  %83 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
  %84 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
  %vecins128 = insertelement <5 x i32> %84, i32 %83, i32 0
  store <5 x i32> %vecins128, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
  %85 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
  %vecins129 = insertelement <5 x i32> %85, i32 %83, i32 0
  store <5 x i32> %vecins129, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
  %86 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
  %87 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
  %vecins130 = insertelement <5 x i32> %87, i32 %86, i32 0
  store <5 x i32> %vecins130, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
  %88 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
  %vecins131 = insertelement <5 x i32> %88, i32 %86, i32 0
  store <5 x i32> %vecins131, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
  %89 = load i32, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
  store i32 %89, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
  %90 = load i32, i32 addrspace(1)* inttoptr (i32 1064 to i32 addrspace(1)*), align 4
  br label %for.cond132

for.cond132:                                      ; preds = %for.inc274, %for.end123
  %storemerge281 = phi i32 [ %90, %for.end123 ], [ %add275, %for.inc274 ]
  store i32 %storemerge281, i32 addrspace(1)* inttoptr (i32 1476 to i32 addrspace(1)*), align 4
  %91 = load i32, i32 addrspace(1)* inttoptr (i32 1068 to i32 addrspace(1)*), align 4
  %cmp133 = icmp slt i32 %storemerge281, %91
  br i1 %cmp133, label %for.body134, label %for.end276

for.body134:                                      ; preds = %for.cond132
  %92 = load i32, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
  %93 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
  %vecins135 = insertelement <5 x i32> %93, i32 %92, i32 1
  store <5 x i32> %vecins135, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
  %add136 = add nsw i32 %92, 1
  %94 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
  %vecins137 = insertelement <5 x i32> %94, i32 %add136, i32 1
  store <5 x i32> %vecins137, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
  %95 = load i32, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
  %add138 = add nsw i32 %95, 2
  %96 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
  %vecins139 = insertelement <5 x i32> %96, i32 %add138, i32 1
  store <5 x i32> %vecins139, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
  %add140 = add nsw i32 %95, 3
  %97 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
  %vecins141 = insertelement <5 x i32> %97, i32 %add140, i32 1
  store <5 x i32> %vecins141, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
  store i32 0, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
  store i32 0, i32 addrspace(1)* inttoptr (i32 1484 to i32 addrspace(1)*), align 4
  %98 = load i32, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
  %99 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
  %vecins142 = insertelement <5 x i32> %99, i32 %98, i32 0
  %100 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins142, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add144 = add nsw i32 %98, 32
  %vecins145 = insertelement <5 x i32> %vecins142, i32 %add144, i32 0
  %101 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins145, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add147 = add nsw i32 %98, 64
  %vecins148 = insertelement <5 x i32> %vecins145, i32 %add147, i32 0
  %102 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins148, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add150 = add nsw i32 %98, 96
  %vecins151 = insertelement <5 x i32> %vecins148, i32 %add150, i32 0
  store <5 x i32> %vecins151, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
  %103 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins151, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %100, i32 0, i1 true, i1 false)
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %101, i32 0, i1 true, i1 false)
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %102, i32 0, i1 true, i1 false)
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %103, i32 0, i1 true, i1 false)
  %104 = load i32, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
  %add152 = add nsw i32 %104, 128
  store i32 %add152, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
  store i32 0, i32 addrspace(1)* inttoptr (i32 1488 to i32 addrspace(1)*), align 4
  store i32 4, i32 addrspace(1)* inttoptr (i32 1492 to i32 addrspace(1)*), align 4
  store i32 8, i32 addrspace(1)* inttoptr (i32 1496 to i32 addrspace(1)*), align 4
  store i32 12, i32 addrspace(1)* inttoptr (i32 1500 to i32 addrspace(1)*), align 4
  %105 = load i32, i32 addrspace(1)* inttoptr (i32 1336 to i32 addrspace(1)*), align 4
  %106 = load i32, i32 addrspace(1)* inttoptr (i32 1332 to i32 addrspace(1)*), align 4
  %sub153 = sub nsw i32 %105, %106
  store i32 %sub153, i32 addrspace(1)* inttoptr (i32 1504 to i32 addrspace(1)*), align 4
  store i32 0, i32 addrspace(1)* inttoptr (i32 1508 to i32 addrspace(1)*), align 4
  br label %do.body

do.body:                                          ; preds = %do.cond246, %for.body134
  %107 = load i32, i32 addrspace(1)* inttoptr (i32 1488 to i32 addrspace(1)*), align 4
  %108 = call i32 @llvm.tpc.ld.l.i32(i32 %107, i32 0, i32 undef, i1 true, i1 false)
  store i32 %108, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
  %add155 = add nsw i32 %107, 16
  store i32 %add155, i32 addrspace(1)* inttoptr (i32 1488 to i32 addrspace(1)*), align 4
  %109 = load i32, i32 addrspace(1)* inttoptr (i32 1492 to i32 addrspace(1)*), align 4
  %110 = call i32 @llvm.tpc.ld.l.i32(i32 %109, i32 0, i32 undef, i1 true, i1 false)
  store i32 %110, i32 addrspace(1)* inttoptr (i32 1516 to i32 addrspace(1)*), align 4
  %add156 = add nsw i32 %109, 16
  store i32 %add156, i32 addrspace(1)* inttoptr (i32 1492 to i32 addrspace(1)*), align 4
  %111 = load i32, i32 addrspace(1)* inttoptr (i32 1496 to i32 addrspace(1)*), align 4
  %112 = call i32 @llvm.tpc.ld.l.i32(i32 %111, i32 0, i32 undef, i1 true, i1 false)
  store i32 %112, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
  %add157 = add nsw i32 %111, 16
  store i32 %add157, i32 addrspace(1)* inttoptr (i32 1496 to i32 addrspace(1)*), align 4
  %113 = load i32, i32 addrspace(1)* inttoptr (i32 1500 to i32 addrspace(1)*), align 4
  %114 = call i32 @llvm.tpc.ld.l.i32(i32 %113, i32 0, i32 undef, i1 true, i1 false)
  store i32 %114, i32 addrspace(1)* inttoptr (i32 1524 to i32 addrspace(1)*), align 4
  %add158 = add nsw i32 %113, 16
  store i32 %add158, i32 addrspace(1)* inttoptr (i32 1500 to i32 addrspace(1)*), align 4
  %115 = load i32, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
  %116 = load i32, i32 addrspace(1)* inttoptr (i32 1516 to i32 addrspace(1)*), align 4
  %117 = call i32 @llvm.tpc.max.i32.i32.i32.i1(i32 %115, i32 %116, i8 2, i32 0, i32 undef, i1 true, i1 false)
  %118 = load i32, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
  %119 = load i32, i32 addrspace(1)* inttoptr (i32 1524 to i32 addrspace(1)*), align 4
  %120 = call i32 @llvm.tpc.max.i32.i32.i32.i1(i32 %118, i32 %119, i8 2, i32 0, i32 undef, i1 true, i1 false)
  %121 = call i32 @llvm.tpc.max.i32.i32.i32.i1(i32 %117, i32 %120, i8 2, i32 0, i32 undef, i1 true, i1 false)
  store i32 %121, i32 addrspace(1)* inttoptr (i32 1528 to i32 addrspace(1)*), align 4
  %122 = load i32, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
  %123 = load i32, i32 addrspace(1)* inttoptr (i32 1516 to i32 addrspace(1)*), align 4
  %add159 = add nsw i32 %122, %123
  store i32 %add159, i32 addrspace(1)* inttoptr (i32 1532 to i32 addrspace(1)*), align 4
  %124 = load i32, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
  %125 = load i32, i32 addrspace(1)* inttoptr (i32 1524 to i32 addrspace(1)*), align 4
  %add160 = add nsw i32 %124, %125
  store i32 %add160, i32 addrspace(1)* inttoptr (i32 1536 to i32 addrspace(1)*), align 4
  %126 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
  %127 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
  %vecins161 = insertelement <5 x i32> %127, i32 %126, i32 0
  store <5 x i32> %vecins161, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
  %128 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
  %vecins162 = insertelement <5 x i32> %128, i32 %126, i32 0
  store <5 x i32> %vecins162, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
  %129 = load i32, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
  %add164 = add nsw i32 %126, %129
  %vecins165 = insertelement <5 x i32> %vecins162, i32 %add164, i32 0
  store <5 x i32> %vecins165, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
  %130 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
  %131 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
  %vecins166 = insertelement <5 x i32> %131, i32 %130, i32 0
  store <5 x i32> %vecins166, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
  %132 = load i32, i32 addrspace(1)* inttoptr (i32 1532 to i32 addrspace(1)*), align 4
  %add168 = add nsw i32 %130, %132
  %vecins169 = insertelement <5 x i32> %vecins166, i32 %add168, i32 0
  store <5 x i32> %vecins169, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
  %133 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
  %134 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
  %vecins170 = insertelement <5 x i32> %134, i32 %133, i32 0
  store <5 x i32> %vecins170, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
  %135 = load i32, i32 addrspace(1)* inttoptr (i32 1532 to i32 addrspace(1)*), align 4
  %136 = load i32, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
  %add171 = add nsw i32 %135, %136
  %add173 = add nsw i32 %133, %add171
  %vecins174 = insertelement <5 x i32> %vecins170, i32 %add173, i32 0
  store <5 x i32> %vecins174, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
  %137 = load i32, i32 addrspace(1)* inttoptr (i32 1536 to i32 addrspace(1)*), align 4
  %add175 = add nsw i32 %135, %137
  store i32 %add175, i32 addrspace(1)* inttoptr (i32 1540 to i32 addrspace(1)*), align 4
  %138 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
  %add176 = add nsw i32 %138, %add175
  store i32 %add176, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
  %139 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
  %140 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %139, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext177 = extractelement <5 x i32> %139, i32 0
  %add178 = add nsw i32 %vecext177, 1
  %vecins179 = insertelement <5 x i32> %139, i32 %add178, i32 0
  store <5 x i32> %vecins179, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
  %141 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
  %142 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %141, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext180 = extractelement <5 x i32> %141, i32 0
  %add181 = add nsw i32 %vecext180, 1
  %vecins182 = insertelement <5 x i32> %141, i32 %add181, i32 0
  store <5 x i32> %vecins182, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
  %143 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
  %144 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %143, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext183 = extractelement <5 x i32> %143, i32 0
  %add184 = add nsw i32 %vecext183, 1
  %vecins185 = insertelement <5 x i32> %143, i32 %add184, i32 0
  store <5 x i32> %vecins185, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
  %145 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
  %146 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %145, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext186 = extractelement <5 x i32> %145, i32 0
  %add187 = add nsw i32 %vecext186, 1
  %vecins188 = insertelement <5 x i32> %145, i32 %add187, i32 0
  store <5 x i32> %vecins188, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
  store <64 x float> zeroinitializer, <64 x float> addrspace(2)* inttoptr (i32 1024 to <64 x float> addrspace(2)*), align 256
  store <64 x float> zeroinitializer, <64 x float> addrspace(2)* inttoptr (i32 1280 to <64 x float> addrspace(2)*), align 256
  store <64 x float> zeroinitializer, <64 x float> addrspace(2)* inttoptr (i32 1536 to <64 x float> addrspace(2)*), align 256
  store <64 x float> zeroinitializer, <64 x float> addrspace(2)* inttoptr (i32 1792 to <64 x float> addrspace(2)*), align 256
  store i32 0, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
  br label %do.body189

do.body189:                                       ; preds = %do.cond, %do.body
  %indicesCoordPtr0.0.in = phi i8 addrspace(3)* [ %140, %do.body ], [ %162, %do.cond ]
  %indicesCoordPtr1.0.in = phi i8 addrspace(3)* [ %142, %do.body ], [ %164, %do.cond ]
  %indicesCoordPtr2.0.in = phi i8 addrspace(3)* [ %144, %do.body ], [ %166, %do.cond ]
  %indicesCoordPtr3.0.in = phi i8 addrspace(3)* [ %146, %do.body ], [ %168, %do.cond ]
  %147 = load i32, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
  %148 = load i32, i32 addrspace(1)* inttoptr (i32 1512 to i32 addrspace(1)*), align 4
  %149 = call i1 @llvm.tpc.cmp.less.i1.i32.i32.i1(i32 %147, i32 %148, i8 2, i32 0, i1 undef, i1 true, i1 false)
  %conv = zext i1 %149 to i8
  store i8 %conv, i8 addrspace(1)* inttoptr (i32 1548 to i8 addrspace(1)*), align 1
  %150 = load i32, i32 addrspace(1)* inttoptr (i32 1516 to i32 addrspace(1)*), align 4
  %151 = call i1 @llvm.tpc.cmp.less.i1.i32.i32.i1(i32 %147, i32 %150, i8 2, i32 0, i1 undef, i1 true, i1 false)
  %conv190 = zext i1 %151 to i8
  store i8 %conv190, i8 addrspace(1)* inttoptr (i32 1552 to i8 addrspace(1)*), align 1
  %152 = load i32, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
  %153 = load i32, i32 addrspace(1)* inttoptr (i32 1520 to i32 addrspace(1)*), align 4
  %154 = call i1 @llvm.tpc.cmp.less.i1.i32.i32.i1(i32 %152, i32 %153, i8 2, i32 0, i1 undef, i1 true, i1 false)
  %conv191 = zext i1 %154 to i8
  store i8 %conv191, i8 addrspace(1)* inttoptr (i32 1556 to i8 addrspace(1)*), align 1
  %155 = load i32, i32 addrspace(1)* inttoptr (i32 1524 to i32 addrspace(1)*), align 4
  %156 = call i1 @llvm.tpc.cmp.less.i1.i32.i32.i1(i32 %152, i32 %155, i8 2, i32 0, i1 undef, i1 true, i1 false)
  %conv192 = zext i1 %156 to i8
  store i8 %conv192, i8 addrspace(1)* inttoptr (i32 1560 to i8 addrspace(1)*), align 1
  %157 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %indicesCoordPtr0.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %157, i32 addrspace(1)* inttoptr (i32 1564 to i32 addrspace(1)*), align 4
  %158 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %indicesCoordPtr1.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %158, i32 addrspace(1)* inttoptr (i32 1568 to i32 addrspace(1)*), align 4
  %159 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %indicesCoordPtr2.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %159, i32 addrspace(1)* inttoptr (i32 1572 to i32 addrspace(1)*), align 4
  %160 = call i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)* %indicesCoordPtr3.0.in, i32 0, i32 undef, i1 true, i1 false)
  store i32 %160, i32 addrspace(1)* inttoptr (i32 1576 to i32 addrspace(1)*), align 4
  %161 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
  %162 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %161, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext193 = extractelement <5 x i32> %161, i32 0
  %add194 = add nsw i32 %vecext193, 1
  %vecins195 = insertelement <5 x i32> %161, i32 %add194, i32 0
  store <5 x i32> %vecins195, <5 x i32> addrspace(1)* inttoptr (i32 1244 to <5 x i32> addrspace(1)*), align 4
  %163 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
  %164 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %163, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext196 = extractelement <5 x i32> %163, i32 0
  %add197 = add nsw i32 %vecext196, 1
  %vecins198 = insertelement <5 x i32> %163, i32 %add197, i32 0
  store <5 x i32> %vecins198, <5 x i32> addrspace(1)* inttoptr (i32 1264 to <5 x i32> addrspace(1)*), align 4
  %165 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
  %166 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %165, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext199 = extractelement <5 x i32> %165, i32 0
  %add200 = add nsw i32 %vecext199, 1
  %vecins201 = insertelement <5 x i32> %165, i32 %add200, i32 0
  store <5 x i32> %vecins201, <5 x i32> addrspace(1)* inttoptr (i32 1284 to <5 x i32> addrspace(1)*), align 4
  %167 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
  %168 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %167, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %vecext202 = extractelement <5 x i32> %167, i32 0
  %add203 = add nsw i32 %vecext202, 1
  %vecins204 = insertelement <5 x i32> %167, i32 %add203, i32 0
  store <5 x i32> %vecins204, <5 x i32> addrspace(1)* inttoptr (i32 1304 to <5 x i32> addrspace(1)*), align 4
  %169 = load i32, i32 addrspace(1)* inttoptr (i32 1564 to i32 addrspace(1)*), align 4
  %170 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
  %vecins205 = insertelement <5 x i32> %170, i32 %169, i32 1
  store <5 x i32> %vecins205, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
  %171 = load i32, i32 addrspace(1)* inttoptr (i32 1568 to i32 addrspace(1)*), align 4
  %172 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
  %vecins206 = insertelement <5 x i32> %172, i32 %171, i32 1
  store <5 x i32> %vecins206, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
  %173 = load i32, i32 addrspace(1)* inttoptr (i32 1572 to i32 addrspace(1)*), align 4
  %174 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
  %vecins207 = insertelement <5 x i32> %174, i32 %173, i32 1
  store <5 x i32> %vecins207, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
  %175 = load i32, i32 addrspace(1)* inttoptr (i32 1576 to i32 addrspace(1)*), align 4
  %176 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
  %vecins208 = insertelement <5 x i32> %176, i32 %175, i32 1
  store <5 x i32> %vecins208, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
  %177 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
  %178 = call <64 x float> @llvm.tpc.ld.tnsr.v64f32.i1(<5 x i32> %177, i8 0, i32 0, <64 x float> undef, i1 true, i1 false)
  store <64 x float> %178, <64 x float> addrspace(2)* null, align 256
  %179 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
  %180 = call <64 x float> @llvm.tpc.ld.tnsr.v64f32.i1(<5 x i32> %179, i8 0, i32 0, <64 x float> undef, i1 true, i1 false)
  store <64 x float> %180, <64 x float> addrspace(2)* inttoptr (i32 256 to <64 x float> addrspace(2)*), align 256
  %181 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
  %182 = call <64 x float> @llvm.tpc.ld.tnsr.v64f32.i1(<5 x i32> %181, i8 0, i32 0, <64 x float> undef, i1 true, i1 false)
  store <64 x float> %182, <64 x float> addrspace(2)* inttoptr (i32 512 to <64 x float> addrspace(2)*), align 256
  %183 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
  %184 = call <64 x float> @llvm.tpc.ld.tnsr.v64f32.i1(<5 x i32> %183, i8 0, i32 0, <64 x float> undef, i1 true, i1 false)
  store <64 x float> %184, <64 x float> addrspace(2)* inttoptr (i32 768 to <64 x float> addrspace(2)*), align 256
  %185 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1024 to <64 x float> addrspace(2)*), align 256
  %186 = load <64 x float>, <64 x float> addrspace(2)* null, align 256
  %187 = load i8, i8 addrspace(1)* inttoptr (i32 1548 to i8 addrspace(1)*), align 1
  %tobool = icmp ne i8 %187, 0
  %188 = call <64 x float> @llvm.tpc.add.v64f32.v64f32.v64f32.i1(<64 x float> %185, <64 x float> %186, i8 0, i32 0, <64 x float> %185, i1 %tobool, i1 false)
  store <64 x float> %188, <64 x float> addrspace(2)* inttoptr (i32 1024 to <64 x float> addrspace(2)*), align 256
  %189 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1280 to <64 x float> addrspace(2)*), align 256
  %190 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 256 to <64 x float> addrspace(2)*), align 256
  %191 = load i8, i8 addrspace(1)* inttoptr (i32 1552 to i8 addrspace(1)*), align 1
  %tobool209 = icmp ne i8 %191, 0
  %192 = call <64 x float> @llvm.tpc.add.v64f32.v64f32.v64f32.i1(<64 x float> %189, <64 x float> %190, i8 0, i32 0, <64 x float> %189, i1 %tobool209, i1 false)
  store <64 x float> %192, <64 x float> addrspace(2)* inttoptr (i32 1280 to <64 x float> addrspace(2)*), align 256
  %193 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1536 to <64 x float> addrspace(2)*), align 256
  %194 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 512 to <64 x float> addrspace(2)*), align 256
  %195 = load i8, i8 addrspace(1)* inttoptr (i32 1556 to i8 addrspace(1)*), align 1
  %tobool210 = icmp ne i8 %195, 0
  %196 = call <64 x float> @llvm.tpc.add.v64f32.v64f32.v64f32.i1(<64 x float> %193, <64 x float> %194, i8 0, i32 0, <64 x float> %193, i1 %tobool210, i1 false)
  store <64 x float> %196, <64 x float> addrspace(2)* inttoptr (i32 1536 to <64 x float> addrspace(2)*), align 256
  %197 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1792 to <64 x float> addrspace(2)*), align 256
  %198 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 768 to <64 x float> addrspace(2)*), align 256
  %199 = load i8, i8 addrspace(1)* inttoptr (i32 1560 to i8 addrspace(1)*), align 1
  %tobool211 = icmp ne i8 %199, 0
  %200 = call <64 x float> @llvm.tpc.add.v64f32.v64f32.v64f32.i1(<64 x float> %197, <64 x float> %198, i8 0, i32 0, <64 x float> %197, i1 %tobool211, i1 false)
  store <64 x float> %200, <64 x float> addrspace(2)* inttoptr (i32 1792 to <64 x float> addrspace(2)*), align 256
  %201 = load i32, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
  %add212 = add nsw i32 %201, 1
  store i32 %add212, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
  br label %do.cond

do.cond:                                          ; preds = %do.body189
  %202 = load i32, i32 addrspace(1)* inttoptr (i32 1544 to i32 addrspace(1)*), align 4
  %203 = load i32, i32 addrspace(1)* inttoptr (i32 1528 to i32 addrspace(1)*), align 4
  %cmp213 = icmp slt i32 %202, %203
  br i1 %cmp213, label %do.body189, label %do.end, !llvm.loop !7

do.end:                                           ; preds = %do.cond
  %204 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
  %205 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1024 to <64 x float> addrspace(2)*), align 256
  call void @llvm.tpc.st.tnsr.v64f32(<5 x i32> %204, i8 4, <64 x float> %205, i32 0, i1 true, i1 false)
  %vecext215 = extractelement <5 x i32> %204, i32 1
  %add216 = add nsw i32 %vecext215, 4
  %vecins217 = insertelement <5 x i32> %204, i32 %add216, i32 1
  store <5 x i32> %vecins217, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
  %206 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
  %207 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1280 to <64 x float> addrspace(2)*), align 256
  call void @llvm.tpc.st.tnsr.v64f32(<5 x i32> %206, i8 4, <64 x float> %207, i32 0, i1 true, i1 false)
  %vecext218 = extractelement <5 x i32> %206, i32 1
  %add219 = add nsw i32 %vecext218, 4
  %vecins220 = insertelement <5 x i32> %206, i32 %add219, i32 1
  store <5 x i32> %vecins220, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
  %208 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
  %209 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1536 to <64 x float> addrspace(2)*), align 256
  call void @llvm.tpc.st.tnsr.v64f32(<5 x i32> %208, i8 4, <64 x float> %209, i32 0, i1 true, i1 false)
  %vecext221 = extractelement <5 x i32> %208, i32 1
  %add222 = add nsw i32 %vecext221, 4
  %vecins223 = insertelement <5 x i32> %208, i32 %add222, i32 1
  store <5 x i32> %vecins223, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
  %210 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
  %211 = load <64 x float>, <64 x float> addrspace(2)* inttoptr (i32 1792 to <64 x float> addrspace(2)*), align 256
  call void @llvm.tpc.st.tnsr.v64f32(<5 x i32> %210, i8 4, <64 x float> %211, i32 0, i1 true, i1 false)
  %vecext224 = extractelement <5 x i32> %210, i32 1
  %add225 = add nsw i32 %vecext224, 4
  %vecins226 = insertelement <5 x i32> %210, i32 %add225, i32 1
  store <5 x i32> %vecins226, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
  %212 = load i32, i32 addrspace(1)* inttoptr (i32 1540 to i32 addrspace(1)*), align 4
  %213 = load i32, i32 addrspace(1)* inttoptr (i32 1484 to i32 addrspace(1)*), align 4
  %add227 = add nsw i32 %213, %212
  store i32 %add227, i32 addrspace(1)* inttoptr (i32 1484 to i32 addrspace(1)*), align 4
  %add228 = add nsw i32 %add227, 96
  %214 = load i32, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
  %215 = call i1 @llvm.tpc.cmp.geq.i1.i32.i32.i1(i32 %add228, i32 %214, i8 2, i32 0, i1 undef, i1 true, i1 false)
  %conv229 = zext i1 %215 to i8
  store i8 %conv229, i8 addrspace(1)* inttoptr (i32 1580 to i8 addrspace(1)*), align 1
  %216 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
  %217 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
  %vecins230 = insertelement <5 x i32> %217, i32 %216, i32 0
  %218 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins230, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add232 = add nsw i32 %216, 32
  %vecins233 = insertelement <5 x i32> %vecins230, i32 %add232, i32 0
  %219 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins233, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add235 = add nsw i32 %216, 64
  %vecins236 = insertelement <5 x i32> %vecins233, i32 %add235, i32 0
  %220 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins236, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %add238 = add nsw i32 %216, 96
  %vecins239 = insertelement <5 x i32> %vecins236, i32 %add238, i32 0
  store <5 x i32> %vecins239, <5 x i32> addrspace(1)* inttoptr (i32 1372 to <5 x i32> addrspace(1)*), align 4
  %221 = call i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32> %vecins239, i8 1, i32 0, i8 addrspace(3)* undef, i1 true, i1 false)
  %222 = load i8, i8 addrspace(1)* inttoptr (i32 1580 to i8 addrspace(1)*), align 1
  %tobool240 = icmp ne i8 %222, 0
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %218, i32 0, i1 %tobool240, i1 false)
  %tobool241 = icmp ne i8 %222, 0
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %219, i32 0, i1 %tobool241, i1 false)
  %tobool242 = icmp ne i8 %222, 0
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %220, i32 0, i1 %tobool242, i1 false)
  %223 = load i8, i8 addrspace(1)* inttoptr (i32 1580 to i8 addrspace(1)*), align 1
  %tobool243 = icmp ne i8 %223, 0
  call void @llvm.tpc.prefetch(i8 addrspace(3)* %221, i32 0, i1 %tobool243, i1 false)
  %224 = load i32, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
  %tobool244 = icmp ne i8 %223, 0
  %225 = call i32 @llvm.tpc.add.i32.i32.i32.i1(i32 %224, i32 32, i8 2, i32 0, i32 %224, i1 %tobool244, i1 false)
  store i32 %225, i32 addrspace(1)* inttoptr (i32 1480 to i32 addrspace(1)*), align 4
  %226 = load i32, i32 addrspace(1)* inttoptr (i32 1508 to i32 addrspace(1)*), align 4
  %add245 = add nsw i32 %226, 4
  store i32 %add245, i32 addrspace(1)* inttoptr (i32 1508 to i32 addrspace(1)*), align 4
  br label %do.cond246

do.cond246:                                       ; preds = %do.end
  %227 = load i32, i32 addrspace(1)* inttoptr (i32 1508 to i32 addrspace(1)*), align 4
  %228 = load i32, i32 addrspace(1)* inttoptr (i32 1504 to i32 addrspace(1)*), align 4
  %cmp247 = icmp slt i32 %227, %228
  br i1 %cmp247, label %do.body, label %do.end249, !llvm.loop !8

do.end249:                                        ; preds = %do.cond246
  %229 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
  %vecext250 = extractelement <5 x i32> %229, i32 0
  %add251 = add nsw i32 %vecext250, 64
  %vecins252 = insertelement <5 x i32> %229, i32 %add251, i32 0
  store <5 x i32> %vecins252, <5 x i32> addrspace(1)* inttoptr (i32 1084 to <5 x i32> addrspace(1)*), align 4
  %230 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
  %vecext253 = extractelement <5 x i32> %230, i32 0
  %add254 = add nsw i32 %vecext253, 64
  %vecins255 = insertelement <5 x i32> %230, i32 %add254, i32 0
  store <5 x i32> %vecins255, <5 x i32> addrspace(1)* inttoptr (i32 1104 to <5 x i32> addrspace(1)*), align 4
  %231 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
  %vecext256 = extractelement <5 x i32> %231, i32 0
  %add257 = add nsw i32 %vecext256, 64
  %vecins258 = insertelement <5 x i32> %231, i32 %add257, i32 0
  store <5 x i32> %vecins258, <5 x i32> addrspace(1)* inttoptr (i32 1124 to <5 x i32> addrspace(1)*), align 4
  %232 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
  %vecext259 = extractelement <5 x i32> %232, i32 0
  %add260 = add nsw i32 %vecext259, 64
  %vecins261 = insertelement <5 x i32> %232, i32 %add260, i32 0
  store <5 x i32> %vecins261, <5 x i32> addrspace(1)* inttoptr (i32 1144 to <5 x i32> addrspace(1)*), align 4
  %233 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
  %vecext262 = extractelement <5 x i32> %233, i32 0
  %add263 = add nsw i32 %vecext262, 64
  %vecins264 = insertelement <5 x i32> %233, i32 %add263, i32 0
  store <5 x i32> %vecins264, <5 x i32> addrspace(1)* inttoptr (i32 1164 to <5 x i32> addrspace(1)*), align 4
  %234 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
  %vecext265 = extractelement <5 x i32> %234, i32 0
  %add266 = add nsw i32 %vecext265, 64
  %vecins267 = insertelement <5 x i32> %234, i32 %add266, i32 0
  store <5 x i32> %vecins267, <5 x i32> addrspace(1)* inttoptr (i32 1184 to <5 x i32> addrspace(1)*), align 4
  %235 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
  %vecext268 = extractelement <5 x i32> %235, i32 0
  %add269 = add nsw i32 %vecext268, 64
  %vecins270 = insertelement <5 x i32> %235, i32 %add269, i32 0
  store <5 x i32> %vecins270, <5 x i32> addrspace(1)* inttoptr (i32 1204 to <5 x i32> addrspace(1)*), align 4
  %236 = load <5 x i32>, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
  %vecext271 = extractelement <5 x i32> %236, i32 0
  %add272 = add nsw i32 %vecext271, 64
  %vecins273 = insertelement <5 x i32> %236, i32 %add272, i32 0
  store <5 x i32> %vecins273, <5 x i32> addrspace(1)* inttoptr (i32 1224 to <5 x i32> addrspace(1)*), align 4
  br label %for.inc274

for.inc274:                                       ; preds = %do.end249
  %237 = load i32, i32 addrspace(1)* inttoptr (i32 1476 to i32 addrspace(1)*), align 4
  %add275 = add nsw i32 %237, 64
  br label %for.cond132, !llvm.loop !9

for.end276:                                       ; preds = %for.cond132
  %238 = load i32, i32 addrspace(1)* inttoptr (i32 1472 to i32 addrspace(1)*), align 4
  store i32 %238, i32 addrspace(1)* inttoptr (i32 1324 to i32 addrspace(1)*), align 4
  br label %for.inc277

for.inc277:                                       ; preds = %for.end276
  %239 = load i32, i32 addrspace(1)* inttoptr (i32 1348 to i32 addrspace(1)*), align 4
  %add278 = add nsw i32 %239, 256
  br label %for.cond, !llvm.loop !10

for.end279:                                       ; preds = %for.cond
  ret void
}

; Function Attrs: nounwind readnone
declare <5 x i32> @llvm.tpc.get.index.space.offset() #1

; Function Attrs: nounwind readnone
declare <5 x i32> @llvm.tpc.get.index.space.size() #1

; Function Attrs: nounwind readnone
declare i8 addrspace(3)* @llvm.tpc.gen.addr(<5 x i32>, i8, i32, i8 addrspace(3)*, i1, i1) #1

; Function Attrs: nounwind readonly
declare i32 @llvm.tpc.ld.g.i32(i8 addrspace(3)*, i32, i32, i1, i1) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.tpc.min.i32.i32.i32.i1(i32, i32, i8, i32, i32, i1, i1) #1

; Function Attrs: inaccessiblemem_or_argmemonly nounwind
declare void @llvm.tpc.prefetch(i8 addrspace(3)*, i32, i1, i1) #3

; Function Attrs: nounwind readonly
declare i32 @llvm.tpc.ld.l.i32(i32, i32, i32, i1, i1) #2

; Function Attrs: nounwind readnone
declare i32 @llvm.tpc.max.i32.i32.i32.i1(i32, i32, i8, i32, i32, i1, i1) #1

; Function Attrs: nounwind readnone
declare i1 @llvm.tpc.cmp.less.i1.i32.i32.i1(i32, i32, i8, i32, i1, i1, i1) #1

; Function Attrs: nounwind readnone
declare <64 x float> @llvm.tpc.ld.tnsr.v64f32.i1(<5 x i32>, i8, i32, <64 x float>, i1, i1) #1

; Function Attrs: nounwind readnone
declare <64 x float> @llvm.tpc.add.v64f32.v64f32.v64f32.i1(<64 x float>, <64 x float>, i8, i32, <64 x float>, i1, i1) #1

; Function Attrs: nounwind writeonly
declare void @llvm.tpc.st.tnsr.v64f32(<5 x i32>, i8, <64 x float>, i32, i1, i1) #4

; Function Attrs: nounwind readnone
declare i1 @llvm.tpc.cmp.geq.i1.i32.i32.i1(i32, i32, i8, i32, i1, i1, i1) #1

; Function Attrs: nounwind readnone
declare i32 @llvm.tpc.add.i32.i32.i32.i1(i32, i32, i8, i32, i32, i1, i1) #1

attributes #0 = { noinline nounwind "correctly-rounded-divide-sqrt-fp-math"="false" "disable-tail-calls"="false" "less-precise-fpmad"="false" "no-frame-pointer-elim"="true" "no-frame-pointer-elim-non-leaf" "no-infs-fp-math"="false" "no-jump-tables"="false" "no-nans-fp-math"="false" "no-signed-zeros-fp-math"="false" "no-trapping-math"="false" "stack-protector-buffer-size"="8" "target-cpu"="gaudi" "target-features"="+gaudi" "unsafe-fp-math"="false" "use-soft-float"="false" }
attributes #1 = { nounwind readnone }
attributes #2 = { nounwind readonly }
attributes #3 = { inaccessiblemem_or_argmemonly nounwind }
attributes #4 = { nounwind writeonly }

!llvm.module.flags = !{!0}
!llvm.ident = !{!1}
!llvm.tpc.scalar_data = !{!2}
!llvm.tpc.vector_data = !{!3}

!0 = !{i32 1, !"wchar_size", i32 4}
!1 = !{!"clang version 7.0.0 (ssh://gerrit:29418/tpc_clang2 80a0a209e04a31e8f0eacc32134ef0a097b5a0c3) (ssh://gerrit:29418/tpc_llvm2 2278757240f4a1661b39e040250ba3e4baadfdab)"}
!2 = !{i32 1584}
!3 = !{i32 2048}
!4 = distinct !{!4, !5}
!5 = !{!"llvm.loop.taken", i1 true}
!6 = distinct !{!6, !5}
!7 = distinct !{!7, !5}
!8 = distinct !{!8, !5}
!9 = distinct !{!9, !5}
!10 = distinct !{!10, !5}
